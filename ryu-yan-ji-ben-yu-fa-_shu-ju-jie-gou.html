
<!DOCTYPE html>
<html lang="cn"
>
<head>
    <title>R语言基本语法_数据结构 - Café de Lyon</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="wb:webmaster" content="3cba1a80be39e3a2" />



<link rel="canonical" href="http://www.lyon0804.com/ryu-yan-ji-ben-yu-fa-_shu-ju-jie-gou.html">

        <meta name="author" content="lyon" />
        <meta name="keywords" content="R" />
        <meta name="description" content="R语言数据结构 如果有Python使用经验, 可以比较容易地站在numpy、pandas等数据分析套件的基础上理解R语言中数据结构, 主要分为以下几种: 向量(vector, 有时也被称为atomic vector), 向量中的每个元素都必须是同一种类型(同质性), 向量是一个固定的内存区域, 不支持插入和删除元素, 这相当于生成一个新的向量, 但是做切片操作等不会改变其内存空间中的数据存储区域, 而只需要改变某一个控制字段即可; (可类比numpy中ndarray的存储结构) 矩阵(matrix), 矩阵本质上也是向量, 只不过添加了行数和列数属性而已; 数组(array), 数组是更加一般化的矩阵, 可以包含多维信息, 矩阵是一个二维的数组; 列表(list, 有时也称为rcursive vector, 递归型向量), 和向量不同的是, list支持元素具有不同的类型(异质性), 并且支持插入删除合并等一系列操作; 列表看上去和结构体类似, 每一个元素都是列表的组件; 更像是C中的结构体或者Python中的字典等等; 数据框(dataframe), 数据框也支持其中包含多种类型, 如果列表是异质的向量, 则可以理解为数据框是异质的矩阵; 但是在实际使用中, 列表往往比数据框具有更加灵活的应用, 而避免太过复杂的数据框, 对数据框正确的理解应该是: 具有相同长度的向量组件的列表 ..." />

        <meta property="og:site_name" content="Café de Lyon" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="R语言基本语法_数据结构"/>
        <meta property="og:url" content="http://www.lyon0804.com/ryu-yan-ji-ben-yu-fa-_shu-ju-jie-gou.html"/>
        <meta property="og:description" content="R语言数据结构 如果有Python使用经验, 可以比较容易地站在numpy、pandas等数据分析套件的基础上理解R语言中数据结构, 主要分为以下几种: 向量(vector, 有时也被称为atomic vector), 向量中的每个元素都必须是同一种类型(同质性), 向量是一个固定的内存区域, 不支持插入和删除元素, 这相当于生成一个新的向量, 但是做切片操作等不会改变其内存空间中的数据存储区域, 而只需要改变某一个控制字段即可; (可类比numpy中ndarray的存储结构) 矩阵(matrix), 矩阵本质上也是向量, 只不过添加了行数和列数属性而已; 数组(array), 数组是更加一般化的矩阵, 可以包含多维信息, 矩阵是一个二维的数组; 列表(list, 有时也称为rcursive vector, 递归型向量), 和向量不同的是, list支持元素具有不同的类型(异质性), 并且支持插入删除合并等一系列操作; 列表看上去和结构体类似, 每一个元素都是列表的组件; 更像是C中的结构体或者Python中的字典等等; 数据框(dataframe), 数据框也支持其中包含多种类型, 如果列表是异质的向量, 则可以理解为数据框是异质的矩阵; 但是在实际使用中, 列表往往比数据框具有更加灵活的应用, 而避免太过复杂的数据框, 对数据框正确的理解应该是: 具有相同长度的向量组件的列表 ..."/>
        <meta property="article:published_time" content="2016-03-05" />
            <meta property="article:section" content="Learning" />
            <meta property="article:tag" content="R" />
            <meta property="article:author" content="lyon" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://www.lyon0804.com/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://www.lyon0804.com/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://www.lyon0804.com/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://www.lyon0804.com/theme/css/style.css" type="text/css"/>

        <link href="http://www.lyon0804.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Café de Lyon ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://www.lyon0804.com/" class="navbar-brand">
<img src="http://www.lyon0804.com/static/img/logo.png" width="30px"/> Café de Lyon            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="http://www.lyon0804.com/category/bioinformatics.html">Bioinformatics</a>
                        </li>
                        <li class="active">
                            <a href="http://www.lyon0804.com/category/learning.html">Learning</a>
                        </li>
                        <li >
                            <a href="http://www.lyon0804.com/category/pages.html">Pages</a>
                        </li>
                        <li >
                            <a href="http://www.lyon0804.com/category/photo.html">Photo</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://www.lyon0804.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">

    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://www.lyon0804.com/ryu-yan-ji-ben-yu-fa-_shu-ju-jie-gou.html"
                       rel="bookmark"
                       title="Permalink to R语言基本语法_数据结构">
                        R语言基本语法_数据结构
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2016-03-05T00:00:00+08:00"> Sat 05 March 2016</time>
    </span>



<span class="label label-default">Tags</span>
	<a href="http://www.lyon0804.com/tag/r.html">R</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <h2>R语言数据结构</h2>
<p>如果有Python使用经验, 可以比较容易地站在<strong>numpy</strong>、<strong>pandas</strong>等数据分析套件的基础上理解R语言中数据结构, 主要分为以下几种:</p>
<ol>
<li>向量(vector, 有时也被称为atomic vector), 向量中的每个元素都必须是同一种类型(同质性), 向量是一个固定的内存区域, 不支持插入和删除元素, 这相当于生成一个新的向量, 但是做切片操作等不会改变其内存空间中的数据存储区域, 而只需要改变某一个控制字段即可; (可类比numpy中ndarray的存储结构)</li>
<li>矩阵(matrix), 矩阵本质上也是向量, 只不过添加了行数和列数属性而已;</li>
<li>数组(array), 数组是更加一般化的矩阵, 可以包含多维信息, 矩阵是一个二维的数组; </li>
<li>列表(list, 有时也称为rcursive vector, 递归型向量), 和向量不同的是, list支持元素具有不同的类型(异质性), 并且支持插入删除合并等一系列操作; 列表看上去和结构体类似, 每一个元素都是列表的组件; 更像是C中的结构体或者Python中的字典等等;</li>
<li>数据框(dataframe), 数据框也支持其中包含多种类型, 如果列表是异质的向量, 则可以理解为数据框是异质的矩阵; 但是在实际使用中, 列表往往比数据框具有更加灵活的应用, 而避免太过复杂的数据框, 对数据框正确的理解应该是: 具有相同长度的向量组件的列表; 可能比较拗口, 但是列表中的组件可以是数据框, 而数据框中的组件则一般肯定为向量以便于数据分析;</li>
<li>因子(factor), 因子是用数字对向量内容编码后的向量, 具有levels属性来对一系列的值或者字符串做编码;</li>
<li>表(table), 表常常由数据框通过table()函数得到, 具有行名、列名等属性;</li>
<li>类(class), R中的类来源于<strong>S语言</strong>的灵感, 以列表的形式体现, 分为S3类和S4类; </li>
</ol>
<p>R中可以使用<code>typeof()</code>函数来判断向量类型, 或者使用<code>mode()</code>来判断向量的模式, 这里的模式比类型的范围稍大一些, 比如integer和double是两种不同类型, 但是他们都是同一种(numeric)模式;</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">typeof</span><span class="p">(</span>x<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;double&quot;</span>
<span class="o">&gt;</span> <span class="kp">mode</span><span class="p">(</span>x<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;numeric&quot;</span>
</pre></div>


<h2>向量</h2>
<h3>创建向量</h3>
<p>R中没有标量的概念, 任何标量都是一元向量, 由于向量的同质性, 其中的每个元素都必须是同一种类型, 通过<code>c()</code>函数()可以生成一个向量:</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="m">5</span>
<span class="o">&gt;</span> x
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">5</span>
<span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">8</span><span class="p">)</span>
<span class="o">&gt;</span> x
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">4</span> <span class="m">2</span> <span class="m">8</span>
<span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span>x<span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">],</span> <span class="m">5</span><span class="p">,</span> x<span class="p">[</span><span class="m">3</span><span class="o">:</span><span class="m">4</span><span class="p">])</span>
<span class="o">&gt;</span> x
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">4</span> <span class="m">5</span> <span class="m">2</span> <span class="m">8</span>
</pre></div>


<p>逐行解释以上结果:</p>
<p>上面是在R语言交互式界面中的输入输出结果, <code>&lt;-</code>是R中的赋值操作符, 可以看到, 如果对一个变量赋值标量数据, 实际上仍然是以向量的形式显示, 只不过这个向量只有一个元素;</p>
<p>如果要对向量进行元素插入的操作, 则必须使用上述后三行的方式, 通过这种方式插入元素的操作来得到; </p>
<p>而和Python一样, R中的变量名称实际上只是一个指针, 这意味着上述的插入操作实际上是构成了一个新的向量, 而又将x指向新向量的内存空间; 这就意味着向量操作存在一个陷阱, 如果对一个大的向量频繁进行插入或者改变的操作, 程序性能将会大大下降;</p>
<p>由于向量的同质性, 如果在<code>c()</code>函数操作过程中传入两个类型不同的向量, 则向量的类型会往<strong>较宽</strong>的方向自动转换:</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span><span class="m">5</span>
<span class="o">&gt;</span> <span class="kp">typeof</span><span class="p">(</span>x<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;integer&quot;</span>
<span class="o">&gt;</span> y <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">typeof</span><span class="p">(</span>y<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;character&quot;</span>
<span class="o">&gt;</span> z <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span>x<span class="p">,</span> y<span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">typeof</span><span class="p">(</span>z<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;character&quot;</span>
</pre></div>


<p>向量的访问通过<code>[]</code>进行, 其中包含需要访问到的下标数组; 如果有Python经验的同学需要注意, R里也支持负数作为访问下标, 但是和Python中的意义不同, R中的负数下标表示<strong>舍去</strong>某个下标对应元素的含义; 同时, 应该注意到在R里面, 下标是从<strong>1</strong>开始的, 而不是<strong>0</strong>;</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span><span class="m">5</span>
<span class="o">&gt;</span> x<span class="p">[</span><span class="m">-1</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>
</pre></div>


<p>除了最基本的<code>c()</code>之外, 还可以通过以下的方式创建向量:</p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="m">2</span><span class="o">:</span><span class="m">8</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span>
<span class="o">&gt;</span> <span class="m">8</span><span class="o">:</span><span class="m">2</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">8</span> <span class="m">7</span> <span class="m">6</span> <span class="m">5</span> <span class="m">4</span> <span class="m">3</span> <span class="m">2</span>
<span class="o">&gt;</span> <span class="kp">seq</span><span class="p">(</span><span class="kt">c</span><span class="p">(</span><span class="m">4</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">))</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span>
<span class="o">&gt;</span> <span class="kp">seq</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> by<span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">3</span> <span class="m">5</span> <span class="m">7</span> <span class="m">9</span>
<span class="o">&gt;</span> <span class="kp">seq</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> length.out<span class="o">=</span><span class="m">7</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">1.0</span>  <span class="m">2.5</span>  <span class="m">4.0</span>  <span class="m">5.5</span>  <span class="m">7.0</span>  <span class="m">8.5</span> <span class="m">10.0</span>
<span class="o">&gt;</span> <span class="kp">seq</span><span class="p">(</span>from<span class="o">=</span><span class="m">12</span><span class="p">,</span> to<span class="o">=</span><span class="m">30</span><span class="p">,</span> length<span class="o">=</span><span class="m">10</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">12</span> <span class="m">14</span> <span class="m">16</span> <span class="m">18</span> <span class="m">20</span> <span class="m">22</span> <span class="m">24</span> <span class="m">26</span> <span class="m">28</span> <span class="m">30</span>
<span class="o">&gt;</span> <span class="kp">rep</span><span class="p">(</span><span class="m">6</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">6</span> <span class="m">6</span> <span class="m">6</span>
<span class="o">&gt;</span> <span class="kp">rep</span><span class="p">(</span><span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">),</span> <span class="m">2</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span>
<span class="o">&gt;</span> <span class="kp">rep</span><span class="p">(</span><span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">),</span> each<span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">1</span> <span class="m">2</span> <span class="m">2</span> <span class="m">3</span> <span class="m">3</span> 
<span class="o">&gt;</span> e <span class="o">&lt;-</span> <span class="kt">vector</span><span class="p">(</span>length<span class="o">=</span><span class="m">20</span><span class="p">)</span>
</pre></div>


<p>等等;</p>
<p>第一种方式使用<code>:</code>来创建一个连续的向量, 也是用来生成下标数组最常用快捷的方式(当然意味着下标数组可以用任何一种方式来生成, 如:<code>x[rep(c(1,2), 2)]</code>等); 用这种方式得到的向量是整形的向量(integer), 而用<code>c()</code>函数得到的确实double类型的向量(虽然他们的模式都是numeric);</p>
<p>第二种方式可以使用<code>seq()</code>函数创建向量, 该函数接收一个向量参数时, 会直接返回其下标数组, 这种方式是得到向量下标的最佳实践(由于R语言中下标从1开始, 如果使用<code>length()</code>函数等方法很容易在向量为空时发生错误); 该函数同时还支持步长和输出长度两种方式控制向量的生成;</p>
<p>第三种方式是对已有向量的重复扩展, 支持times和each两种方式, 分别将向量整个重复, 以及每个元素重复后组成向量等(具体看上面的例子), 当这两种方式共用时, each操作将会具有较高优先级(这是理所当然的, 否则each将失去意义);</p>
<p>第四种方式是为了避免对向量大小进行修改时, 会频繁对向量重新分配内存造成的性能问题, 则可以用<code>vector()</code>函数创建一个空的足够大的向量容器, 之后对该容器中的元素进行修改即可, 而不用多次重新分配内存;</p>
<h3>向量常用操作</h3>
<p>向量具有很多操作函数, 常用的有: </p>
<ul>
<li><code>length()</code>: 取得向量的长度(即元素个数);</li>
<li><code>all()</code>: 判断向量中是否全部元素都满足条件;</li>
<li><code>any()</code>: 判断向量中是否至少有一个元素满足条件;</li>
</ul>
<p>由于向量是R中的最小存储单位, 所以在其他语言中印象中的所有标量函数(包含操作符)都可以应用于向量:</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="o">&gt;</span> y <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">)</span>
<span class="o">&gt;</span> x <span class="o">&gt;</span> <span class="m">2</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="kc">FALSE</span> <span class="kc">FALSE</span>  <span class="kc">TRUE</span>
<span class="o">&gt;</span> x <span class="o">+</span> y
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">5</span> <span class="m">7</span> <span class="m">9</span>
<span class="o">&gt;</span> x <span class="o">-</span> y
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">-3</span> <span class="m">-3</span> <span class="m">-3</span>
<span class="o">&gt;</span> x <span class="o">*</span> y
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">4</span> <span class="m">10</span> <span class="m">18</span>
<span class="o">&gt;</span> x <span class="o">/</span> y
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">0.25</span> <span class="m">0.40</span> <span class="m">0.50</span>
<span class="o">&gt;</span> <span class="kp">sqrt</span><span class="p">(</span>x<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1.000000</span> <span class="m">1.414214</span> <span class="m">1.732051</span>
<span class="o">&gt;</span> foo <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>x<span class="p">)</span> <span class="kr">return</span><span class="p">(</span>x <span class="o">**</span> <span class="m">2</span><span class="p">)</span>
<span class="o">&gt;</span> foo<span class="p">(</span>x<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">4</span> <span class="m">9</span>
</pre></div>


<p>由上可见, R中的函数几乎都是向量化的(包含逻辑运算, 所以有些操作必须要借助<code>all()</code>和<code>any()</code>进行), 在R中判断是否是其他语言印象中的标量, 只能通过判断向量长度是否为1进行; 这和<code>numpy</code>中的<code>ufunc</code>如出一辙, 不同的是R在语言层面上就决定所有函数的想量化, 而<code>numpy</code>则必须在python的限制下做出一些让步;</p>
<p>R中还支持向量化的三元操作符<code>ifelse()</code>函数, 该函数可以对向量进行快速的三元操作:</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span><span class="m">10</span>
<span class="o">&gt;</span> y <span class="o">&lt;-</span> <span class="kp">ifelse</span><span class="p">(</span>x <span class="o">%%</span> <span class="m">2</span> <span class="o">==</span> <span class="m">0</span><span class="p">,</span> <span class="s">&#39;odd&#39;</span><span class="p">,</span> <span class="s">&#39;even&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> y
 <span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;even&quot;</span> <span class="s">&quot;odd&quot;</span>  <span class="s">&quot;even&quot;</span> <span class="s">&quot;odd&quot;</span>  <span class="s">&quot;even&quot;</span> <span class="s">&quot;odd&quot;</span>  <span class="s">&quot;even&quot;</span> <span class="s">&quot;odd&quot;</span>  <span class="s">&quot;even&quot;</span> <span class="s">&quot;odd&quot;</span>
</pre></div>


<p>向量化的运算非常广泛, 甚至判断相等的操作符: <code>==</code>都是向量化的, 所以用来判断两个向量是否相等用<code>==</code>来进行得到的结果会是一个布尔型向量, 而判断两个向量是否真正相同, 还需要借助其他的函数;</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span><span class="m">5</span>
<span class="o">&gt;</span> y <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
<span class="o">&gt;</span> x
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>
<span class="o">&gt;</span> y
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>
<span class="o">&gt;</span> x <span class="o">==</span> y
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="kc">TRUE</span> <span class="kc">TRUE</span> <span class="kc">TRUE</span> <span class="kc">TRUE</span> <span class="kc">TRUE</span>
<span class="o">&gt;</span> <span class="kp">all</span><span class="p">(</span>x <span class="o">==</span> y<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="kc">TRUE</span>
<span class="o">&gt;</span> <span class="kp">identical</span><span class="p">(</span>x<span class="p">,</span> y<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="kc">FALSE</span>
<span class="o">&gt;</span> <span class="kp">typeof</span><span class="p">(</span>x<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;integer&quot;</span>
<span class="o">&gt;</span> <span class="kp">typeof</span><span class="p">(</span>y<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;double&quot;</span>
</pre></div>


<p>可以看到, 使用<code>==</code>比较时是值运算, 只比较两个值是否相等, 使用这种方式不会将向量的类型纳入考虑范围之中, 而使用<code>identical()</code>时, 则需要两个向量完全一样, 包括类型也要完全一致;</p>
<p>同时向量会在操作之前进行最简单的广播(broadcast), 以确保进行操作的两个向量具有相同的长度:</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="o">&gt;</span> y <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span><span class="m">6</span>
<span class="o">&gt;</span> x <span class="o">+</span> y
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2</span> <span class="m">4</span> <span class="m">6</span> <span class="m">5</span> <span class="m">7</span> <span class="m">9</span>
</pre></div>


<p>这个特性在矩阵中也同样得到体现;</p>
<p>在R中应该尽可能避免循环操作, 而使用向量化操作符代替, 由于向量化操作符操作更高效的内存空间, 在执行效率上会比使用循环快很多;</p>
<h3>特殊变量</h3>
<p>在R中有两个特殊变量: <strong>NA</strong>和<strong>NULL</strong>, NA表示缺失值, 而NULL表示不存在, 我粗浅的理解是: NA表示指针指向一段未初始化的内存, 而NULL表示指针为空(没有指向具体的内存);</p>
<p>在R中, 许多函数都具有跳过NA的参数<code>na.rm</code>, 将其设置为<code>TRUE</code>, 则该函数在对向量进行计算时会直接跳过NA:</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="kc">NA</span><span class="p">,</span> <span class="m">23</span><span class="p">,</span> <span class="kc">NA</span><span class="p">,</span> <span class="m">41</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">mean</span><span class="p">(</span>x<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="kc">NA</span>
<span class="o">&gt;</span> <span class="kp">mean</span><span class="p">(</span>x<span class="p">,</span> na.rm<span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">22.66667</span>
</pre></div>


<p>如上例当存在NA时, 无法进行平均值计算, 得到结果也是NA, 但是将<code>na.rm</code>参数设置为TRUE之后, 则可以正常计算出平均值; <strong>注意:</strong> 这里是直接将NA排除, 所以总数也降为3而不是原始的长度5;</p>
<p>由于NA只是指向了一段未初始化的内存, 但是这段内存的长度等属性是在向量创建时就决定的, 所以在不同的向量中, NA具有不同的类型:</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="kc">NA</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">typeof</span><span class="p">(</span>x<span class="p">[</span><span class="m">2</span><span class="p">])</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;double&quot;</span>
<span class="o">&gt;</span> y <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="kc">NA</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">typeof</span><span class="p">(</span>y<span class="p">[</span><span class="m">2</span><span class="p">])</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;character&quot;</span>
</pre></div>


<p>而NULL由于是未定义的值, 所以其没有类型, 并且向量长度为0;</p>
<h3>向量筛选</h3>
<p>向量除了使用数字下标访问内容之外, 还可以使用布尔型向量访问内容, 当下标为<strong>TRUE</strong>时表示访问, 而<strong>FALSE</strong>就是不访问; 而通过逻辑运算可以得到一个布尔型向量, 这种方式常用于<strong>向量筛选</strong>; </p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">,</span> <span class="kc">NA</span><span class="p">)</span>
<span class="o">&gt;</span> x
 <span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">1</span>  <span class="m">2</span>  <span class="m">3</span>  <span class="m">4</span>  <span class="m">5</span>  <span class="m">6</span>  <span class="m">7</span>  <span class="m">8</span>  <span class="m">9</span> <span class="m">10</span> <span class="kc">NA</span>
<span class="o">&gt;</span> x <span class="o">&gt;</span> <span class="m">2</span>
 <span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="kc">FALSE</span> <span class="kc">FALSE</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>    <span class="kc">NA</span>
<span class="o">&gt;</span> x<span class="p">[</span>x<span class="o">&gt;</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">3</span>  <span class="m">4</span>  <span class="m">5</span>  <span class="m">6</span>  <span class="m">7</span>  <span class="m">8</span>  <span class="m">9</span> <span class="m">10</span> <span class="kc">NA</span>
</pre></div>


<p>用布尔型向量的方式筛选向量的问题是, 当向量中存在NA时, 这种方式得到的结果会包含NA, 如果不想在结果中包含NA的话, 则需要用到<code>subset()</code>函数;</p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="kp">subset</span><span class="p">(</span>x<span class="p">,</span> x<span class="o">&gt;</span><span class="m">2</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">3</span>  <span class="m">4</span>  <span class="m">5</span>  <span class="m">6</span>  <span class="m">7</span>  <span class="m">8</span>  <span class="m">9</span> <span class="m">10</span>
</pre></div>


<p>向量筛选还有一个函数<code>which()</code>, 不同的是, 该函数只是返回向量的下标, 并且只返回确定符合要求的下标, 所以NA并不包含在其中;</p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="kp">which</span><span class="p">(</span>x<span class="o">&gt;</span><span class="m">2</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">3</span>  <span class="m">4</span>  <span class="m">5</span>  <span class="m">6</span>  <span class="m">7</span>  <span class="m">8</span>  <span class="m">9</span> <span class="m">10</span>
<span class="o">&gt;</span> x<span class="p">[</span><span class="kp">which</span><span class="p">(</span>x <span class="o">&gt;</span> <span class="m">2</span><span class="p">)]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">3</span>  <span class="m">4</span>  <span class="m">5</span>  <span class="m">6</span>  <span class="m">7</span>  <span class="m">8</span>  <span class="m">9</span> <span class="m">10</span>
</pre></div>


<p><code>which()</code>函数可以用来找到符合要求的元素在向量中的具体位置, 当然<code>which()</code>得到的具体位置(下标)可以用来访问原来向量中的元素, 但是并不推荐这么做, 因为有更好的办法(直接用布尔型下标或者<code>subset()</code>更加符合设计的初衷);</p>
<h3>命名向量</h3>
<p>向量可以被指定名称, 指定名称之后, 可以用向量的名称来更直观访问一个向量;</p>
<div class="highlight"><pre><span class="o">&gt;</span> x <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;2016-03-06&#39;</span><span class="p">,</span> <span class="s">&#39;hangzhou&#39;</span><span class="p">,</span> <span class="s">&#39;haze&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">names</span><span class="p">(</span>x<span class="p">)</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;date&#39;</span><span class="p">,</span> <span class="s">&#39;city&#39;</span><span class="p">,</span> <span class="s">&#39;weather&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> x
        date         city      weather 
<span class="s">&quot;2016-03-06&quot;</span>   <span class="s">&quot;hangzhou&quot;</span>       <span class="s">&quot;haze&quot;</span> 
<span class="o">&gt;</span> x<span class="p">[</span><span class="s">&#39;city&#39;</span><span class="p">]</span>
      city 
<span class="s">&quot;hangzhou&quot;</span> 
<span class="o">&gt;</span> <span class="kp">names</span><span class="p">(</span>x<span class="p">)</span> <span class="o">&lt;-</span> <span class="kc">NULL</span>
<span class="o">&gt;</span> x
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;2016-03-06&quot;</span> <span class="s">&quot;hangzhou&quot;</span>   <span class="s">&quot;haze&quot;</span>    
</pre></div>


<h2>矩阵</h2>
<h3>创建矩阵</h3>
<p>矩阵本质上是一个特殊的向量, 这个向量包含两个附加的属性: 行数、列数; 因此矩阵的创建依赖于向量的创建:</p>
<div class="highlight"><pre><span class="o">&gt;</span> m <span class="o">&lt;-</span> <span class="kt">matrix</span><span class="p">(</span>data<span class="o">=</span><span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="o">:</span><span class="m">5</span><span class="p">,</span><span class="m">4</span><span class="p">),</span> nrow<span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span> <span class="p">[,</span><span class="m">3</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">3</span>    <span class="m">5</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">4</span>    <span class="m">4</span>
<span class="o">&gt;</span> m <span class="o">&lt;-</span> <span class="kt">matrix</span><span class="p">(</span>data<span class="o">=</span><span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="o">:</span><span class="m">5</span><span class="p">,</span><span class="m">4</span><span class="p">),</span> nrow<span class="o">=</span><span class="m">2</span><span class="p">,</span> byrow<span class="o">=</span><span class="bp">T</span><span class="p">)</span>
<span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span> <span class="p">[,</span><span class="m">3</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">2</span>    <span class="m">3</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">4</span>    <span class="m">5</span>    <span class="m">4</span>
</pre></div>


<p>矩阵创建时, <code>data</code>参数提供了一个矩阵的内容, <code>nrow</code>或者<code>ncol</code>提供矩阵的形状, 在创建过程中, 可以看成将<code>data</code>中的数据按照指定的形状逐一输入到矩阵中;</p>
<p>可以看出, 矩阵默认是按照列顺序输入值的, 通过<code>byrow</code>参数可以将输入顺序改为行顺序, 但是不论输入顺序如何, 在存储形式上都是按照列顺序存储的(当个一个向量和矩阵运算时, 矩阵可以看成按列顺序展开的向量);</p>
<p>还有一种创建方式是通过向量的操作得到, 当对向量的函数输出结果为一个向量时, 结果向量的长度则是输入向量长度和输出向量长度之积, 如一个函数输出一个长度为2的向量, 则当输入向量长度为5时, 最终得到的结果向量的长度为10; 该结果向量可以作为data传入到<code>matrix()</code>函数中创建矩阵, 也可以通过<code>sapply()</code>(<em>simplify apply</em>)函数直接得到一个矩阵:</p>
<div class="highlight"><pre><span class="o">&gt;</span> square <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>x<span class="p">)</span> <span class="kr">return</span><span class="p">(</span><span class="kt">c</span><span class="p">(</span>x<span class="p">,</span> x<span class="o">^</span><span class="m">2</span><span class="p">))</span>
<span class="o">&gt;</span> 
<span class="o">&gt;</span> square<span class="p">(</span><span class="m">2</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2</span> <span class="m">4</span>
<span class="o">&gt;</span> square<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">)</span>
 <span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">1</span>  <span class="m">2</span>  <span class="m">3</span>  <span class="m">4</span>  <span class="m">5</span>  <span class="m">1</span>  <span class="m">4</span>  <span class="m">9</span> <span class="m">16</span> <span class="m">25</span>
<span class="o">&gt;</span> <span class="kt">matrix</span><span class="p">(</span>square<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">),</span> nrow<span class="o">=</span><span class="m">2</span><span class="p">,</span> byrow<span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span> <span class="p">[,</span><span class="m">3</span><span class="p">]</span> <span class="p">[,</span><span class="m">4</span><span class="p">]</span> <span class="p">[,</span><span class="m">5</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">2</span>    <span class="m">3</span>    <span class="m">4</span>    <span class="m">5</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">4</span>    <span class="m">9</span>   <span class="m">16</span>   <span class="m">25</span>
<span class="o">&gt;</span> <span class="kp">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">,</span> square<span class="p">)</span>
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span> <span class="p">[,</span><span class="m">3</span><span class="p">]</span> <span class="p">[,</span><span class="m">4</span><span class="p">]</span> <span class="p">[,</span><span class="m">5</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">2</span>    <span class="m">3</span>    <span class="m">4</span>    <span class="m">5</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">4</span>    <span class="m">9</span>   <span class="m">16</span>   <span class="m">25</span>
</pre></div>


<p>另外, 矩阵可以通过<code>cbind()</code>(<em>column bind</em>)、<code>rbind()</code>(<em>row bind</em>)两个函数进行创建;</p>
<div class="highlight"><pre><span class="o">&gt;</span> m <span class="o">=</span> <span class="kp">rbind</span><span class="p">(</span><span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">),</span> <span class="kt">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">))</span>
<span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">2</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">4</span>
<span class="o">&gt;</span> m <span class="o">=</span> <span class="kp">cbind</span><span class="p">(</span><span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">),</span> <span class="kt">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">))</span>
<span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">3</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">4</span>
</pre></div>


<h3>矩阵常用操作</h3>
<p>一旦得到一个矩阵, 则可以对其进行大量线性代数的运算, 其中包括:</p>
<ol>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>: 各种四则运算, 当其中一个参数为向量, 则该向量会被循环补齐到和矩阵同样的大小再做运算, <strong>注意</strong>: 矩阵存储方式是按列存储, 所以和向量的运算也是按列的顺序; 如果两个参数都为矩阵, 则必须保证矩阵的形状相同;</li>
<li><code>%*%</code>: 矩阵叉乘;</li>
<li><code>t()</code>: 矩阵转置;</li>
<li><code>crossprod()</code>: 矩阵内积;</li>
<li><code>solve()</code>: 解线性方程组;</li>
<li><code>qr()</code>: 矩阵QR分解;</li>
<li><code>chol()</code>: 矩阵Cholesky分解;</li>
<li><code>det()</code>: 矩阵行列式值;</li>
<li><code>eigen()</code>: 矩阵特征值和特征向量;</li>
<li><code>diag()</code>: 从方阵中提出对角矩阵;</li>
<li><code>sweep()</code>: 数值分析批量运算符;</li>
</ol>
<p>除了以上线性代数运算的内容之外, 对于矩阵的一般操作如访问、赋值、筛选等等操作, 都遵循向量操作时的一般规则:</p>
<div class="highlight"><pre><span class="o">&gt;</span> m <span class="o">&lt;-</span> <span class="kt">matrix</span><span class="p">(</span>data<span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">,</span> ncol<span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">length</span><span class="p">(</span>m<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">10</span>
<span class="o">&gt;</span> <span class="kp">nrow</span><span class="p">(</span>m<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">5</span>
<span class="o">&gt;</span> <span class="kp">ncol</span><span class="p">(</span>m<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2</span>
<span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">6</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">7</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">8</span>
<span class="p">[</span><span class="m">4</span><span class="p">,]</span>    <span class="m">4</span>    <span class="m">9</span>
<span class="p">[</span><span class="m">5</span><span class="p">,]</span>    <span class="m">5</span>   <span class="m">10</span>
<span class="o">&gt;</span> m<span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">6</span>  <span class="m">7</span>  <span class="m">8</span>  <span class="m">9</span> <span class="m">10</span>
<span class="o">&gt;</span> m<span class="p">[</span><span class="m">3</span><span class="p">,]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">3</span> <span class="m">8</span>
<span class="o">&gt;</span> m<span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">3</span>
<span class="o">&gt;</span> m<span class="p">[</span><span class="m">2</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">7</span> <span class="m">8</span>
<span class="o">&gt;</span> m<span class="p">[</span><span class="m">2</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="m">2</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">)</span>
<span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">6</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">0</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">0</span>
<span class="p">[</span><span class="m">4</span><span class="p">,]</span>    <span class="m">4</span>    <span class="m">9</span>
<span class="p">[</span><span class="m">5</span><span class="p">,]</span>    <span class="m">5</span>   <span class="m">10</span>
</pre></div>


<p>上述例子说明了矩阵元素访问的方式, 同样也是通过下标, 行和列的下标值之间使用逗号分隔; 如果只用一个数值作为下标访问, 则相当于访问矩阵按照列顺序展开后的向量;</p>
<p>同样的, 矩阵也是不可更改的, 任何对矩阵中的元素做出修改的动作都将会重新建立一个矩阵, 从而造成性能浪费;</p>
<p>当矩阵访问得到的结果可以用向量形式表示时, R都会倾向于自动降维, 这在某些场合可能会造成一定的问题(比如访问得到的结果不再适用于矩阵运算), 为了防止自动降维, 可以设置<code>drop=FALSE</code>, 以确保得到的结果仍然是一个矩阵:</p>
<div class="highlight"><pre><span class="o">&gt;</span> m<span class="p">[</span><span class="m">2</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="m">2</span><span class="p">,</span> drop<span class="o">=</span><span class="kc">FALSE</span><span class="p">]</span>
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">0</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">0</span>
</pre></div>


<p>矩阵同样也可以使用布尔值向量来访问, 所以可以做到和向量类似的筛选操作:</p>
<div class="highlight"><pre><span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">6</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">1</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">0</span>
<span class="p">[</span><span class="m">4</span><span class="p">,]</span>    <span class="m">4</span>    <span class="m">9</span>
<span class="p">[</span><span class="m">5</span><span class="p">,]</span>    <span class="m">5</span>   <span class="m">10</span>
<span class="o">&gt;</span> m<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="p">]</span> <span class="o">&gt;</span> <span class="m">3</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="kc">FALSE</span>  <span class="kc">TRUE</span>
<span class="o">&gt;</span> m<span class="p">[</span>m<span class="p">[</span><span class="m">1</span><span class="p">,]</span> <span class="o">&gt;</span> <span class="m">3</span><span class="p">,</span> <span class="p">]</span>
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">1</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">4</span>    <span class="m">9</span>
<span class="o">&gt;</span> m<span class="p">[</span>m<span class="p">[</span><span class="m">1</span><span class="p">,]</span> <span class="o">&gt;</span> <span class="m">3</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">2</span>  <span class="m">4</span>  <span class="m">6</span>  <span class="m">0</span> <span class="m">10</span>
<span class="o">&gt;</span> m <span class="o">&gt;</span> <span class="m">3</span>
      <span class="p">[,</span><span class="m">1</span><span class="p">]</span>  <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span> <span class="kc">FALSE</span>  <span class="kc">TRUE</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span> <span class="kc">FALSE</span> <span class="kc">FALSE</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span> <span class="kc">FALSE</span> <span class="kc">FALSE</span>
<span class="p">[</span><span class="m">4</span><span class="p">,]</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>
<span class="p">[</span><span class="m">5</span><span class="p">,]</span>  <span class="kc">TRUE</span>  <span class="kc">TRUE</span>
<span class="o">&gt;</span> m<span class="p">[</span>m<span class="o">&gt;</span><span class="m">3</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>  <span class="m">4</span>  <span class="m">5</span>  <span class="m">6</span>  <span class="m">9</span> <span class="m">10</span>
</pre></div>


<p>在上述操作中, 对矩阵的某一列进行逻辑操作, 得到一个布尔型向量, 该向量可以用来作为下标访问矩阵, 注意访问矩阵时, 应该使用逗号隔开的两个数值, 如果只有一个值并且没有用逗号, 则会访问矩阵按照列顺序展开的向量; 当直接对矩阵进行逻辑运算时, 得到的将是一个布尔型矩阵, 用该矩阵访问矩阵最终只能得到一个向量;</p>
<p><strong>注意</strong>: 任何对向量操作的函数, 对矩阵操作时, 都会对矩阵进行按列展开为向量的操作, 如: <code>which()</code>, <code>subset()</code>等等, 特别是<code>subset()</code>需要注意, 不论传入的布尔型向量是按照矩阵的第几列取的, 一旦逻辑运算完毕, 该布尔型向量就和矩阵没有关系, 再用<code>subset()</code>操作时, 原矩阵展开为向量再进行操作;</p>
<h3>使用apply()</h3>
<p><code>apply()</code>函数用于操作矩阵或者数组的某一维度, 该函数接收三个以上参数: 矩阵(或者数组), 维度编号(或者名称), 应用的操作函数, 函数的其他参数;</p>
<div class="highlight"><pre><span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">4</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">5</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">6</span>
<span class="o">&gt;</span> <span class="kp">apply</span><span class="p">(</span>m<span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="kp">mean</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2.5</span> <span class="m">3.5</span> <span class="m">4.5</span>
<span class="o">&gt;</span> <span class="kp">apply</span><span class="p">(</span>m<span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="kp">mean</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2</span> <span class="m">5</span>
</pre></div>


<p>如上述操作中, 当维度编号为1时, 对矩阵的每一行都进行<code>mean()</code>运算, 当维度编号为2时, 对矩阵的每一列都进行<code>mean()</code>运算;</p>
<p>当一个函数具有多个参数时, 可以在后面添加需要的参数;</p>
<div class="highlight"><pre><span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">4</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">5</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">6</span>
<span class="o">&gt;</span> f <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>x<span class="p">,</span> b<span class="p">)</span> <span class="kr">return</span> <span class="p">(</span>x <span class="o">+</span> b<span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">apply</span><span class="p">(</span>m <span class="p">,</span><span class="m">1</span> <span class="p">,</span>f<span class="p">,</span> b<span class="o">=</span><span class="m">2</span><span class="p">)</span>
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span> <span class="p">[,</span><span class="m">3</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">4</span>    <span class="m">5</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">6</span>    <span class="m">7</span>    <span class="m">8</span>
<span class="o">&gt;</span> <span class="kp">apply</span><span class="p">(</span>m <span class="p">,</span><span class="m">2</span> <span class="p">,</span>f<span class="p">,</span> b<span class="o">=</span><span class="m">2</span><span class="p">)</span>
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">6</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">4</span>    <span class="m">7</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span>    <span class="m">5</span>    <span class="m">8</span>
</pre></div>


<p>注意到, 结果的形状展示时, 由于矩阵是按照列存储的, 所以每一行的结果都会依次以列的顺序保存, 当对行进行运算时, 其结果矩阵和输入矩阵的形状将是互为转置的关系;</p>
<p><code>apply()</code>函数是对循环操作的更简洁描述, 但是并不会对运行性能有很大贡献, 其主要意义在于并行运算以及分布式运算时的应用;</p>
<h3>矩阵命名</h3>
<p>在向量中, 可以通过<code>names()</code>给向量命名, 而给矩阵使用<code>names()</code>命名时, 就会被认为展开的向量, 不能直观反映其中的元素, 用<code>colnames()</code>和<code>rownames()</code>给矩阵命名:</p>
<div class="highlight"><pre><span class="o">&gt;</span> m <span class="o">&lt;-</span> <span class="kt">matrix</span><span class="p">(</span>data<span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span> ncol<span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">4</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">5</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">6</span>
<span class="o">&gt;</span> <span class="kp">names</span><span class="p">(</span>m<span class="p">)</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> m
     <span class="p">[,</span><span class="m">1</span><span class="p">]</span> <span class="p">[,</span><span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,]</span>    <span class="m">1</span>    <span class="m">4</span>
<span class="p">[</span><span class="m">2</span><span class="p">,]</span>    <span class="m">2</span>    <span class="m">5</span>
<span class="p">[</span><span class="m">3</span><span class="p">,]</span>    <span class="m">3</span>    <span class="m">6</span>
<span class="kp">attr</span><span class="p">(,</span><span class="s">&quot;names&quot;</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;d&quot;</span> <span class="s">&quot;e&quot;</span> <span class="s">&quot;f&quot;</span>
<span class="o">&gt;</span> <span class="kp">names</span><span class="p">(</span>m<span class="p">)</span> <span class="o">&lt;-</span> <span class="kc">NULL</span>
<span class="o">&gt;</span> <span class="kp">colnames</span><span class="p">(</span>m<span class="p">)</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kp">rownames</span><span class="p">(</span>m<span class="p">)</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> m
  a b
x <span class="m">1</span> <span class="m">4</span>
y <span class="m">2</span> <span class="m">5</span>
z <span class="m">3</span> <span class="m">6</span>
</pre></div>


<h2>列表</h2>
<h3>创建列表</h3>
<p>列表也是向量, 只不过在R中, 向量默认指的是原子型向量(atomic vector), 而列表则是递归型向量(之所以称为递归型向量, 是因为列表的组件也可以是一个列表), 其长度可以延伸, 并且可以保存不同类型的元素(列表中又称为组件):</p>
<div class="highlight"><pre><span class="o">&gt;</span> l <span class="o">&lt;-</span> <span class="kt">list</span><span class="p">(</span><span class="m">20160306</span><span class="p">,</span> <span class="s">&#39;hangzhou&#39;</span><span class="p">,</span> <span class="s">&#39;haze&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> l
<span class="p">[[</span><span class="m">1</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>

<span class="p">[[</span><span class="m">2</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;hangzhou&quot;</span>

<span class="p">[[</span><span class="m">3</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;haze&quot;</span>

<span class="o">&gt;</span> l <span class="o">&lt;-</span> <span class="kt">list</span><span class="p">(</span>date<span class="o">=</span><span class="m">20160306</span><span class="p">,</span> city<span class="o">=</span><span class="s">&#39;hangzhou&#39;</span><span class="p">,</span> weather<span class="o">=</span><span class="s">&#39;haze&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> l
<span class="o">$</span><span class="kp">date</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>

<span class="o">$</span>city
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;hangzhou&quot;</span>

<span class="o">$</span>weather
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;haze&quot;</span>
<span class="o">&gt;</span> l <span class="o">&lt;-</span> <span class="kt">vector</span><span class="p">(</span>mode<span class="o">=</span><span class="s">&#39;list&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> l
<span class="kt">list</span><span class="p">()</span>
</pre></div>


<p>以上操作说明列表的常用创建方式, 当不指定组件名称时, R会使用默认的数字名称; 也可以使用<code>vector(mode='list')</code>的方式来创建一个空的列表;</p>
<h3>访问列表</h3>
<p>访问列表中的组件具有多种方式, 以上述的<code>l</code>为例:</p>
<div class="highlight"><pre><span class="o">&gt;</span> l
<span class="o">$</span><span class="kp">date</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>

<span class="o">$</span>city
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;hangzhou&quot;</span>

<span class="o">$</span>weather
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;haze&quot;</span>

<span class="o">&gt;</span> l<span class="o">$</span><span class="kp">date</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>
<span class="o">&gt;</span> l<span class="p">[[</span><span class="s">&#39;date&#39;</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>
<span class="o">&gt;</span> l<span class="p">[[</span><span class="m">1</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>
</pre></div>


<p>如上所示, 可以通过<code>$date</code>或者<code>[['date']]</code>或者<code>[[1]]</code>三种方式访问同一个组件, 注意到后面两种方式使用了双层的中括号, 这是因为如果只用一层中括号, 则仅仅只是访问到了子列表, 而非其中的组件;</p>
<div class="highlight"><pre><span class="o">&gt;</span> l<span class="p">[</span><span class="s">&#39;date&#39;</span><span class="p">]</span>
<span class="o">$</span><span class="kp">date</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>

<span class="o">&gt;</span> l<span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">]</span>
<span class="o">$</span><span class="kp">date</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>

<span class="o">$</span>city
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;hangzhou&quot;</span>
</pre></div>


<p>可以任意在列表中添加新的组件, 或者将某一个组件设置为NULL以删除该组件, 注意删除一个组件后, 其之后组件的默认索引值都会改变, 同时也可以使用<code>c()</code>函数拼接多个列表:</p>
<div class="highlight"><pre><span class="o">&gt;</span> l<span class="p">[</span><span class="m">4</span><span class="o">:</span><span class="m">5</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;Sun&#39;</span><span class="p">,</span> <span class="s">&#39;Lib&#39;</span><span class="p">)</span>
<span class="o">&gt;</span> l
<span class="o">$</span><span class="kp">date</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>

<span class="o">$</span>city
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;hangzhou&quot;</span>

<span class="o">$</span>weather
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;haze&quot;</span>

<span class="p">[[</span><span class="m">4</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;Sun&quot;</span>

<span class="p">[[</span><span class="m">5</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;Lib&quot;</span>

<span class="o">&gt;</span> l<span class="p">[</span><span class="m">4</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="kc">NULL</span>
<span class="o">&gt;</span> l
<span class="o">$</span><span class="kp">date</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>

<span class="o">$</span>city
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;hangzhou&quot;</span>

<span class="o">$</span>weather
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;haze&quot;</span>

<span class="p">[[</span><span class="m">4</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;lib&quot;</span>

<span class="o">&gt;</span> l <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span>l<span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">],</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">))</span> 
<span class="o">&gt;</span> <span class="o">&gt;</span> l
<span class="o">$</span><span class="kp">date</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">20160306</span>

<span class="o">$</span>city
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;hangzhou&quot;</span>

<span class="p">[[</span><span class="m">3</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;a&quot;</span>

<span class="p">[[</span><span class="m">4</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;b&quot;</span>

<span class="o">&gt;</span> l<span class="p">[</span><span class="m">3</span><span class="o">:</span><span class="m">4</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="kc">NULL</span>
</pre></div>


<p>列表特有的操作在于可以提取列表的标签和值, 如:</p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="kp">names</span><span class="p">(</span>l<span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;date&quot;</span> <span class="s">&quot;city&quot;</span>
<span class="o">&gt;</span> <span class="kp">unlist</span><span class="p">(</span>l<span class="p">)</span>
      date       city 
<span class="s">&quot;20160306&quot;</span> <span class="s">&quot;hangzhou&quot;</span> 
</pre></div>


<p>其中<code>names()</code>函数返回列表的标签向量, 而<code>unlist()</code>函数则返回列表的值向量, 同时如果这些组件具有名字的话, 返回的将是一个命名向量;</p>
<h3>使用lapply()</h3>
<p>和矩阵中的<code>apply()</code>函数类似, 列表中的<code>lapply()</code>函数将会对列表中每一个组件都进行相同的函数操作, 并且返回一个结果列表;</p>
<div class="highlight"><pre><span class="o">&gt;</span> l <span class="o">&lt;-</span> <span class="kt">list</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">,</span> <span class="m">10</span><span class="o">:</span><span class="m">20</span><span class="p">)</span>
<span class="o">&gt;</span> l
<span class="p">[[</span><span class="m">1</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>

<span class="p">[[</span><span class="m">2</span><span class="p">]]</span>
 <span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">10</span> <span class="m">11</span> <span class="m">12</span> <span class="m">13</span> <span class="m">14</span> <span class="m">15</span> <span class="m">16</span> <span class="m">17</span> <span class="m">18</span> <span class="m">19</span> <span class="m">20</span>

<span class="o">&gt;</span> <span class="kp">lapply</span><span class="p">(</span>l<span class="p">,</span> <span class="kp">mean</span><span class="p">)</span>
<span class="p">[[</span><span class="m">1</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">3</span>

<span class="p">[[</span><span class="m">2</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">15</span>
</pre></div>


<h3>递归型向量</h3>
<p>列表之所以被称为递归型向量, 是因为其组件也可以是一个列表:</p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="kt">list</span><span class="p">(</span>t<span class="o">=</span><span class="kt">list</span><span class="p">(</span>x<span class="o">=</span><span class="m">1</span><span class="p">,</span> y<span class="o">=</span><span class="m">2</span><span class="p">),</span> z<span class="o">=</span><span class="m">3</span><span class="p">)</span>
<span class="o">$</span><span class="kp">t</span>
<span class="o">$</span><span class="kp">t</span><span class="o">$</span>x
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">1</span>

<span class="o">$</span><span class="kp">t</span><span class="o">$</span>y
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2</span>


<span class="o">$</span>z
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">3</span>
</pre></div>


<p>如上所示, 该列表的第一个元素<code>t</code>也是一个列表;</p>
<hr />
<p>未完待续</p>
            </div>
            <!-- /.entry-content -->

    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>
<!--         <div class="ds-thread" data-thread-key="ryu-yan-ji-ben-yu-fa-_shu-ju-jie-gou" data-title="R语言基本语法_数据结构" data-url="http://www.lyon0804.com/ryu-yan-ji-ben-yu-fa-_shu-ju-jie-gou.html"></div> -->
		<script type="text/javascript">
     		var duoshuoQuery = {short_name:"lyon0804"};
    		(function() {
    			var ds = document.createElement('script');
    			ds.type = 'text/javascript';ds.async = true;
    			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    			ds.charset = 'UTF-8';
    			(document.getElementsByTagName('head')[0]
    			 || document.getElementsByTagName('body')[0]).appendChild(ds);
    		})();
    	</script>
        <script type="text/javascript">
            function toggleDuoshuoComments(container, id, title, url){
                if(jQuery(container).has("div").length>0){
                    jQuery(container).empty();
                    return;
                }
                var el = document.createElement('div');
                el.setAttribute('class','ds-thread');
                el.setAttribute('data-thread-key', id);
                el.setAttribute('data-title',title);
                el.setAttribute('data-url', url);
                DUOSHUO.EmbedThread(el);
                jQuery(container).append(el);
            }
        </script>
        <a href="javascript:void(0);" onclick="toggleDuoshuoComments('#comment-box', 'ryu-yan-ji-ben-yu-fa-_shu-ju-jie-gou', 'R语言基本语法_数据结构' , 'http://www.lyon0804.com/ryu-yan-ji-ben-yu-fa-_shu-ju-jie-gou.html');">
        查看评论</a>
        <div id="comment-box" ></div>
        <hr/>
    	<noscript>Please enable JavaScript to view the <a href="http://duoshuo.com/">comments powered by
        Duoshuo.</a></noscript>
    	<a href="http://duoshuo.com" class="dsq-brlink">comments powered by <span>Duoshuo</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
            <!-- <div class="list-group-item"> -->
            <!-- <h4> -->
            <!-- <i class="fa fa-home fa-lg"></i> -->
            <!-- <span class="icon-label">Social</span></h4> -->
              <ul class="list-group" id="social">
                   <!-- <li class="list-group-item"> -->
                   <div class="social-item">
                   <a href="http://github.com/lozybean">
                     <i class="fa fa-github-square fa-lg"></i><!--  github -->
                   </a>
                   </div>
                   <!-- </li> -->
                   <!-- <li class="list-group-item"> -->
                   <div class="social-item">
                   <a href="http://weibo.com/lyon0804">
                     <i class="fa fa-weibo fa-lg"></i><!--  weibo -->
                   </a>
                   </div>
                   <!-- </li> -->
              </ul>
            <!-- </div> -->
         <div class="col-xs-10">&copy; 2017 lyon
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3(modified by lyon)</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2" id="back-top">
            <!-- <p class="pull-right"><i class="fa fa-arrow-up"></i>  -->
            <a href="#top" title="回到顶部"></a>
            </p>
         </div>
      </div>
   </div>
</footer>
<script src="http://www.lyon0804.com/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://www.lyon0804.com/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://www.lyon0804.com/theme/js/respond.min.js"></script>


</body>
</html>