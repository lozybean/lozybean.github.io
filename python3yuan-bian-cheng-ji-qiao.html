
<!DOCTYPE html>
<html lang="cn"
>
<head>
    <title>Python3元编程技巧 - Café de Lyon</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="wb:webmaster" content="3cba1a80be39e3a2" />



<link rel="canonical" href="http://www.lyon0804.com/python3yuan-bian-cheng-ji-qiao.html">

        <meta name="author" content="lyon" />
        <meta name="keywords" content="python,metaprogramming" />
        <meta name="description" content="本文参考David Beazley 13年pycon的演讲整理. 大师写了35年的程序, 依然对新技术保持高度热情, 走在技术的最前面. 甚至现在好多年轻人都执着于py2, 迟迟不肯学习py3, 惧怕新技术带来挑战, 想想真是不应该. 大师是我辈的楷模, 感谢大师的精彩演讲! 什么是元编程 元(Meta)又译为后设, 简单来说就是&#34;关于什么的什么&#34;, &#34;超越什么的什么&#34;, 具体可以参考wiki百科上的解读. 元编程就是&#34;描述编程的编程&#34;, 即操作代码的代码. DRY DRY(don&#39;t repeat yourself)是元编程最初的动机, 为了避免重复代码, 就需要通过一些手段进行代码复用. 为什么不要编写重复代码: 高度重复的代码很差劲; 编写这种代码很沉闷(到处复制粘贴); 代码结构混乱难以阅读; 维护时也需要到处修改, 难以维护; 通过元编程, 可以避免写重复代码, 并且更重要的是, 元编程很好玩, 她令编程充满乐趣. 装饰器 debugging 我们经常用一些print语句来进行debugging ..." />

        <meta property="og:site_name" content="Café de Lyon" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Python3元编程技巧"/>
        <meta property="og:url" content="http://www.lyon0804.com/python3yuan-bian-cheng-ji-qiao.html"/>
        <meta property="og:description" content="本文参考David Beazley 13年pycon的演讲整理. 大师写了35年的程序, 依然对新技术保持高度热情, 走在技术的最前面. 甚至现在好多年轻人都执着于py2, 迟迟不肯学习py3, 惧怕新技术带来挑战, 想想真是不应该. 大师是我辈的楷模, 感谢大师的精彩演讲! 什么是元编程 元(Meta)又译为后设, 简单来说就是&#34;关于什么的什么&#34;, &#34;超越什么的什么&#34;, 具体可以参考wiki百科上的解读. 元编程就是&#34;描述编程的编程&#34;, 即操作代码的代码. DRY DRY(don&#39;t repeat yourself)是元编程最初的动机, 为了避免重复代码, 就需要通过一些手段进行代码复用. 为什么不要编写重复代码: 高度重复的代码很差劲; 编写这种代码很沉闷(到处复制粘贴); 代码结构混乱难以阅读; 维护时也需要到处修改, 难以维护; 通过元编程, 可以避免写重复代码, 并且更重要的是, 元编程很好玩, 她令编程充满乐趣. 装饰器 debugging 我们经常用一些print语句来进行debugging ..."/>
        <meta property="article:published_time" content="2016-10-08" />
            <meta property="article:section" content="bioinformatics" />
            <meta property="article:tag" content="python" />
            <meta property="article:tag" content="metaprogramming" />
            <meta property="article:author" content="lyon" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://www.lyon0804.com/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://www.lyon0804.com/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://www.lyon0804.com/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://www.lyon0804.com/theme/css/style.css" type="text/css"/>

        <link href="http://www.lyon0804.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Café de Lyon ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://www.lyon0804.com/" class="navbar-brand">
<img src="http://www.lyon0804.com/static/img/logo.png" width="30px"/> Café de Lyon            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://www.lyon0804.com/category/bioinformatics.html">Bioinformatics</a>
                        </li>
                        <li >
                            <a href="http://www.lyon0804.com/category/learning.html">Learning</a>
                        </li>
                        <li >
                            <a href="http://www.lyon0804.com/category/pages.html">Pages</a>
                        </li>
                        <li >
                            <a href="http://www.lyon0804.com/category/photo.html">Photo</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://www.lyon0804.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">

    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://www.lyon0804.com/python3yuan-bian-cheng-ji-qiao.html"
                       rel="bookmark"
                       title="Permalink to Python3元编程技巧">
                        Python3元编程技巧
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2016-10-08T00:00:00+08:00"> Sat 08 October 2016</time>
    </span>



<span class="label label-default">Tags</span>
	<a href="http://www.lyon0804.com/tag/python.html">python</a>
        /
	<a href="http://www.lyon0804.com/tag/metaprogramming.html">metaprogramming</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>本文参考<a href="https://www.youtube.com/watch?time_continue=1&amp;v=sPiWg5jSoZI">David Beazley 13年pycon的演讲</a>整理. 
大师写了35年的程序, 依然对新技术保持高度热情, 走在技术的最前面. 甚至现在好多年轻人都执着于py2, 迟迟不肯学习py3, 惧怕新技术带来挑战, 想想真是不应该.
大师是我辈的楷模, 感谢大师的精彩演讲!</p>
<h2>什么是元编程</h2>
<p>元(Meta)又译为后设, 简单来说就是"关于什么的什么", "超越什么的什么", 具体可以参考<a href="https://zh.wikipedia.org/wiki/%E5%BE%8C%E8%A8%AD">wiki百科上的解读</a>.</p>
<p>元编程就是"描述编程的编程", 即操作代码的代码.</p>
<h2>DRY</h2>
<p>DRY(don't repeat yourself)是元编程最初的动机, 为了避免重复代码, 就需要通过一些手段进行代码复用.</p>
<p>为什么不要编写重复代码:</p>
<ol>
<li>高度重复的代码很差劲;</li>
<li>编写这种代码很沉闷(到处复制粘贴);</li>
<li>代码结构混乱难以阅读;</li>
<li>维护时也需要到处修改, 难以维护;</li>
</ol>
<p>通过元编程, 可以避免写重复代码, 并且更重要的是, 元编程很好玩, 她令编程充满乐趣.</p>
<h2>装饰器</h2>
<h3>debugging</h3>
<p>我们经常用一些print语句来进行debugging, 如:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;add&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>


<p>但是当有很多函数需要debugging的时候, 看起来就会像是这样:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;add&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;sub&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;mul&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;div&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
</pre></div>


<p>我们使用了四条雷同的print语句, 这就是重复代码, 一个简单的方式去除这些重复代码, 就是使用装饰器(decorator).</p>
<p>装饰器就是一个返回另外一个函数的封装的函数, 这个返回的函数封装在原来的函数基础上进行一些额外的修饰语句.</p>
<h3>使用装饰器</h3>
<p>下面是一个使用装饰器的例子:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__qualname__</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<p>上面的<code>debug</code>函数中, 最终返回的<code>wrapper</code>就是对<code>func</code>的封装, 并且在func运行之前首先打印函数的名字(就像上文中重复的print语句一样).</p>
<p>接下来我们就通过<code>@</code>符号来使用装饰器, 将之前的四个函数改写为:</p>
<div class="highlight"><pre><span class="nd">@debug</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nd">@debug</span>
<span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

<span class="nd">@debug</span>
<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

<span class="nd">@debug</span>
<span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span> <span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
</pre></div>


<p>虽然看起来代码量没有减少, 但是程序的逻辑却发生很大的变化: </p>
<ol>
<li>debugging代码被孤立到单独的位置;</li>
<li>易于修改debugging, 或者取消debug;</li>
<li>被装饰的函数不需要考虑debug的细节;</li>
</ol>
<h3>函数元信息</h3>
<p><code>functools.wraps</code>将<code>func</code>的元信息拷贝出来, 并将其替换到<code>wrapper</code>函数中. 如果不这样做, 被修饰后的函数就不会继续保留原来的元信息:</p>
<div class="highlight"><pre>## 如果没有@wraps(func)这一行:
&gt;&gt;&gt; add.__qualname__
&#39;debug.&lt;locals&gt;.wrapper&#39;

## 加上@wraps(func)这一行后:
&gt;&gt;&gt; add.__qualname__
&#39;add&#39;
</pre></div>


<p>可以看到, 保留了被修饰函数的元信息后, 整个函数看上去就和原来一样.</p>
<h3>带参数的装饰器</h3>
<p>在debug的时候, 能打印一些前缀信息就好了:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;***add&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>


<p>这就需要用到带参数的装饰器, 看起来是这样的:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">func</span><span class="o">.</span><span class="n">__qualname__</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorate</span>
</pre></div>


<p>用起来是这样的:</p>
<div class="highlight"><pre><span class="nd">@debug</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;xxx&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>


<p>这个装饰器有点难看, 可以通过<code>functools.partial</code>重写:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>

    <span class="n">msg</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">func</span><span class="o">.</span><span class="n">__qualname__</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwrags</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<p><code>functools.partial</code>函数可以生成固定某个参数的子函数, 由于被装饰的函数永远作为最后一个参数传入, 作为装饰器的<code>debug</code>的第一个参数<code>func</code>永远是<code>None</code>, 但是返回的<code>partail(debug, prefix=prefix)</code>相当于只有一个参数<code>func</code>的函数, 就正常完成装饰工作.</p>
<h3>类装饰器</h3>
<p>当需要给一个类里所有的方法都加debug时, 看起来会像是这样:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="nd">@debug</span>
    <span class="k">def</span> <span class="nf">grok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@debug</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@debug</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>


<p>我们又看到了重复性代码, 在每个方法前面都加了一行装饰, 虽然少, 但是秉着<strong>DRY</strong>的原则, 我们可以用类装饰器来统一给所有的方法添加装饰:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">debugmethods</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">debug</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cls</span>
</pre></div>


<p>以上代码的思路是:</p>
<ol>
<li>遍历类字典中所有的对象;</li>
<li>辨别是否callable;</li>
<li>将callable的对象添加装饰;</li>
</ol>
<p>用起来是这样的:</p>
<div class="highlight"><pre><span class="nd">@debugmethods</span>
<span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">grok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>


<p>仅仅装饰一次, 就给类里所有的方法添加了装饰. </p>
<p>这种方法有一个限制: 仅对实例方法有效, 对静态方法和类方法无效. 其原因是: 在类定义完成之前, 不能创建类的引用. 所以在类定义完成之前, 类方法和静态方法都不是callable的.</p>
<h3>访问debug</h3>
<p>为了在每次访问对象属性时进行debug, 需要重写类:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">debugattr</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="n">orig_getattribute</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__getattribute__</span>

    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Get:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orig_getattribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">__getattribute__</span> <span class="o">=</span> <span class="n">__getattribute__</span>

    <span class="k">return</span> <span class="n">cls</span>
</pre></div>


<p>此时, 若对一个类进行上述装饰, 其效果会是这样的:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span>
<span class="n">Get</span><span class="p">:</span> <span class="n">x</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span>
<span class="n">Get</span><span class="p">:</span> <span class="n">y</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>


<h2>元类(MetaClass)</h2>
<h3>创建类的类</h3>
<p>设想现在有一系列的类需要被装饰, 大概是这样子:</p>
<div class="highlight"><pre><span class="nd">@debugmethods</span>
<span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="nd">@debugmethods</span>
<span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@debugmethods</span>
<span class="k">class</span> <span class="nc">Grok</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@debugmethods</span>
<span class="k">class</span> <span class="nc">Mondo</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>好吧, 重复性代码又出现了, 我们需要一个元类(metaclass)来解决.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">debugmeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">clsobj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span>
                                 <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>
        <span class="n">clsobj</span> <span class="o">=</span> <span class="n">debugmethods</span><span class="p">(</span><span class="n">clsobj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clsobj</span>

<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">debugmeta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>在上述元类的定义中, 首先使用super().<strong>new</strong>(cls, clsname, bases, clsdict)语句按照一般方式创建类, 然后在通过下一个clsobj = debugmethods(clsobj)语句来装饰该类.</p>
<p>可以看出, 元类实际上控制的是类的创建过程.</p>
<h3>创建类时发生了什么</h3>
<p>所有的对象都有类/类型, 如:</p>
<div class="highlight"><pre>&gt;&gt;&gt; type(3)
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; type(&#39;xxx&#39;)
&lt;class &#39;str&#39;&gt;
&gt;&gt;&gt; type(2.1)
&lt;class &#39;float&#39;&gt;
</pre></div>


<p>类/类型同样也是对象, 所以也有类型, 类/类型的类型是<code>type</code>类:</p>
<div class="highlight"><pre>&gt;&gt;&gt; class A:
...     pass
...
&gt;&gt;&gt; type(A)
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; type(type)
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; type
&lt;class &#39;type&#39;&gt;
</pre></div>


<p>当有一个如下的类:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;I&#39;m Spam.bar&quot;</span><span class="p">)</span>
</pre></div>


<p>由三个部分组成:</p>
<ol>
<li>类名: Spam</li>
<li>父类: Base</li>
<li>方法(类主体): <strong>init</strong>, bar</li>
</ol>
<p>当这个类被定义时, 其内部依次进行下面几步工作:</p>
<p>1.分离类主体:</p>
<div class="highlight"><pre><span class="n">body</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">def __init__(self, name):</span>
<span class="s">    self.name = name</span>

<span class="s">def bar(self):</span>
<span class="s">    print(&quot;I&#39;m Spam.bar&quot;)</span>
<span class="s">&#39;&#39;&#39;</span>
</pre></div>


<p>2.创建类字典, 默认只是创建一个一般的字典, 作为类在主体声明时的本地命名空间;</p>
<div class="highlight"><pre><span class="n">clsdict</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">__prepare__</span><span class="p">(</span><span class="s">&#39;Spam&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">Base</span><span class="p">,</span> <span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">clsdict</span>
<span class="p">{}</span>
</pre></div>


<p>3.运行类主体, 并返回更新后的字典:</p>
<div class="highlight"><pre><span class="k">exec</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="n">clsdict</span><span class="p">)</span>
</pre></div>


<p>返回的更新后字典就会将本体中的内容添加进来:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">clsdict</span>
<span class="p">{</span><span class="s">&#39;__init__&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">__init__</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">bar</span><span class="o">&gt;</span><span class="p">}</span>
</pre></div>


<p>4.使用类名、父类名、类字典三个部分构造类:</p>
<div class="highlight"><pre><span class="n">Spam</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">&#39;Spam&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">Base</span><span class="p">,),</span> <span class="n">clsdict</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Spam</span>
<span class="n">__main__</span><span class="o">.</span><span class="n">Spam</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Spam</span><span class="p">(</span><span class="s">&#39;Guido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="n">Guido</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
<span class="n">I</span><span class="s">&#39;m Spam.bar</span>
</pre></div>


<h3>元类干了啥</h3>
<p>上文中提到, 元类控制了类的创建过程, 也就是"创建类的类". </p>
<p>在上述类建立过程的描述中, 默认的元类就是<code>type</code>类, Spam类定义时, 相当于:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>指定不同于type的其他类作为元类, 就可以修改类的创建方式, 如上文中的<code>debugmeta</code>:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">debugmeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">clsobj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span>
                                 <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>
        <span class="n">clsobj</span> <span class="o">=</span> <span class="n">debugmethods</span><span class="p">(</span><span class="n">clsobj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clsobj</span>
</pre></div>


<p>此时, 若Spam的元类指定为debugmeta: class Spam(metaclass=debugmeta), 则在创建的第四步, 发生的将会是:</p>
<div class="highlight"><pre>Spam = debugmeta(&#39;Spam&#39;, (Base,), clsdict)
</pre></div>


<p>于是, 创建出的类就自动加上了<code>debugmethods</code>的类装饰.</p>
<h3>为什么要用元类</h3>
<p>元类只是在创建类的过程中添加了类修饰, 其本质上和类修饰是差不多的, 但是元类可以通过继承, 就像遗传性变异一样, 影响所有的子类(而不需要在所有的类前面添加类装饰).</p>
<p>在本节开始之前, 使用元类优化后的将会变成这样:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">debugmeta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Grok</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Mondo</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<h3>结构问题</h3>
<p>设想现在有以下几个类:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="n">Stock:</span>
    <span class="n">def</span> <span class="n">__init__</span>(<span class="k">self</span>, <span class="nb">name</span>, <span class="n">share</span>, <span class="n">price</span>):
        <span class="k">self</span>.<span class="nb">name</span> = <span class="nb">name</span>
        <span class="k">self</span>.<span class="n">share</span> = <span class="n">share</span>
        <span class="k">self</span>.<span class="n">price</span> = <span class="n">price</span>

<span class="k">class</span> <span class="n">Point:</span>
    <span class="n">def</span> <span class="n">__init__</span>(<span class="k">self</span>, <span class="o">x</span>, <span class="n">y</span>):
        <span class="k">self</span>.<span class="o">x</span> = <span class="o">x</span>
        <span class="k">self</span>.<span class="n">y</span> = <span class="n">y</span>

<span class="k">class</span> <span class="n">Host:</span>
    <span class="n">def</span> <span class="n">__init__</span>(<span class="k">self</span>, <span class="n">address</span>, <span class="n">port</span>):
        <span class="k">self</span>.<span class="n">address</span> = <span class="n">address</span>
        <span class="k">self</span>.<span class="n">port</span> = <span class="n">port</span>
</pre></div>


<p>如果你时刻记得<strong>DRY</strong>原则的话, 上述的代码看起来会很难看: 每个init函数里面的内容都是雷同的.</p>
<p>继承一个Structure类可以消除这些重复性代码:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Structure</span><span class="p">:</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Wrong # args&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;share&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Host</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;address&#39;</span><span class="p">,</span> <span class="s">&#39;port&#39;</span><span class="p">]</span>
</pre></div>


<p>看起来可以用:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">123.45</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="s">&#39;ACME&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">shares</span>
<span class="mi">50</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">price</span>
<span class="mf">123.45</span>
</pre></div>


<p>但是其实存在很多问题:</p>
<ul>
<li>不支持键值参数</li>
</ul>
<div class="highlight"><pre>&gt;&gt;&gt; s = Stock(&#39;ACME&#39;, price=123.45, shares=50)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: __init__() got an unexpected keyword argument &#39;shares&#39;
</pre></div>


<ul>
<li>缺失运行时签名:</li>
</ul>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">inspect</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">Stock</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Signature</span> <span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>


<p>签名中只有*args, 而不是具体的属性名称.</p>
<h3>加上签名</h3>
<p>创建签名:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">Signature</span>

<span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">]</span>
<span class="n">sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</pre></div>


<p>签名并不只是一些元数据, 而是封装了这些内容的具体对象.</p>
<p>绑定签名:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">bound_args</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwrags</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bound_args</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>


<p>通过<code>sig.bind</code>方法将位置参数和键值参数绑定到sig对象中, 其返回的<code>bound_args.arguments</code>对象为包含传入参数的OrderedDict.</p>
<p>使用起来就像这样:</p>
<div class="highlight"><pre>&gt;&gt;&gt; func(&#39;ACME&#39;, 50, 91.1)
name = ACME
shares = 50
price = 91.1
&gt;&gt;&gt; func(&#39;ACME&#39;, price=91.1, shares=50)
name = ACME
shares = 50
price = 91.1
</pre></div>


<p>可以看出, 绑定后就支持了键值参数和位置参数.</p>
<p>看起来可以用.</p>
<h3>使用签名重写</h3>
<p>利用签名来解决Structrue中存在的问题:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">Signature</span>

<span class="k">def</span> <span class="nf">make_signature</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> 
                               <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Structure</span><span class="p">:</span>
    <span class="n">__signatue__</span> <span class="o">=</span> <span class="n">make_signature</span><span class="p">([])</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bound</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>


<p>使用改写后的Structure:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">__signature__</span> <span class="o">=</span> <span class="n">make_signature</span><span class="p">([</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">])</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">__signature__</span> <span class="o">=</span> <span class="n">make_signature</span><span class="p">([</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">])</span>

<span class="k">class</span> <span class="nc">Host</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">__signature__</span> <span class="o">=</span> <span class="n">make_signature</span><span class="p">([</span><span class="s">&#39;address&#39;</span><span class="p">,</span> <span class="s">&#39;port&#39;</span><span class="p">])</span>
</pre></div>


<p>之前的问题不复存在:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="n">shares</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mf">91.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="s">&#39;ACME&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">shares</span>
<span class="mi">50</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">price</span>
<span class="mf">91.1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">inspect</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">Stock</span><span class="p">))</span>
<span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">)</span>
</pre></div>


<p>但是上面的实现依然充满着重复性代码, 别着急, 正好可以用之前学到的类装饰器和元类来优化一下.</p>
<h3>使用类装饰器优化</h3>
<p>首先要创建一个带参数的类装饰器, 将类中的属性作为参数:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_signature</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">make_signature</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span>
    <span class="k">return</span> <span class="n">decorate</span>
</pre></div>


<p>用起来看上去是这样的:</p>
<div class="highlight"><pre><span class="nd">@add_signature</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@add_signature</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">):</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>类的属性放到了装饰器的参数中, 这样看起来非常奇怪, 很别扭.</p>
<h3>使用元类优化</h3>
<p>使用元类重写, 思路是讲__signature__作为类的属性, 在类构造的时候加入到类属性字典中.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">StructMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">clsobj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">make_signature</span><span class="p">(</span><span class="n">clsobj</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">clsobj</span><span class="p">,</span> <span class="s">&#39;__signature__&#39;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clsobj</span>

<span class="k">class</span> <span class="nc">Structure</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">StructMeta</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bound</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>


<p>在元类中, 不像类装饰器那样使用装饰器的参数来创建签名, 而是通过类中的_fields列表来创建签名, 用起来是这样的:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Host</span><span class="p">(</span><span class="n">Structrue</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;address&#39;</span><span class="p">,</span> <span class="s">&#39;port&#39;</span><span class="p">]</span>
</pre></div>


<p>看起来和最开始使用的方法一样, 但是却解决了属性签名的问题, 可以愉快地使用位置参数和键值参数了.</p>
<h3>使用建议</h3>
<ul>
<li>当要修改一些无关的类时, 使用类装饰器</li>
<li>当需要使用继承的特性时, 使用元类</li>
<li>不要太快否定某种技术</li>
<li>所有这些工具都注定要一起工作</li>
</ul>
<h2>描述器</h2>
<h3>使用属性</h3>
<p>设想上述<code>Stock</code>类:</p>
<div class="highlight"><pre>&gt;&gt;&gt; s = Stock(&#39;ACME&#39;, 50, 91.1)
&gt;&gt;&gt; s.name = 42
&gt;&gt;&gt; s.shares = &#39;a heck of a lot&#39;
&gt;&gt;&gt; s.price = (23.45 + 2j)
</pre></div>


<p>这很荒唐, 名字不应该是数字, 价格也不可能是复数. </p>
<p>使用类属性增加检查:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fileds</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shares</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shares</span>

    <span class="nd">@shares.setter</span>
    <span class="k">def</span> <span class="nf">shares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;expected int&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Must be &gt;= 0&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shares</span> <span class="o">=</span> <span class="n">value</span>    
</pre></div>


<p>现在shares不能再是字符串了:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="s">&#39;a lot&#39;</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">9</span><span class="p">,</span> <span class="ow">in</span> <span class="n">shares</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="n">expected</span> <span class="nb">int</span>
</pre></div>


<p>看起来解决了问题, 但是我们必须对每一个属性都添加相应的检查, 这势必带来一大波重复性代码.</p>
<h3>描述器协议</h3>
<p>属性实际上是通过描述器来实现的, 一个描述器看起来像是这样的:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Descriptor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>


<p>通过自定义描述器, 就可以改变属性的实现过程.</p>
<p>基本的描述器实现:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Descriptor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;getting...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Can&#39;t delete&quot;</span><span class="p">)</span>
</pre></div>


<p>其中当简单返回<code>__dict__</code>中的内容时, <code>__get__</code>方法可以省略.</p>
<p>使用描述器来定义属性:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="p">(</span><span class="s">&#39;shares&#39;</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="p">(</span><span class="s">&#39;price&#39;</span><span class="p">)</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">share</span>
<span class="n">getting</span><span class="o">...</span>
<span class="mi">50</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">s</span><span class="o">.</span><span class="n">share</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">13</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__delete__</span>
<span class="ne">AttributeError</span><span class="p">:</span> <span class="n">Can</span><span class="s">&#39;t delete</span>
</pre></div>


<h3>添加类型检查</h3>
<p>使用描述器, 就可以在<code>__set__</code>方法中添加类型检查:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Typed</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ty</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Expected {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ty</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Integer</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Float</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="nb">float</span>

<span class="k">class</span> <span class="nc">String</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="nb">str</span>
</pre></div>


<p>使用描述器进行类型检查:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s">&#39;shares&#39;</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="s">&#39;price&#39;</span><span class="p">)</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">share</span> <span class="o">=</span> <span class="s">&#39;a lot&#39;</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__set__</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="n">Expected</span> <span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">int</span><span class="s">&#39;&gt;</span>
</pre></div>


<h3>添加值检查</h3>
<p>当然一个价格除了必须是数字之外, 还必须是非负的.</p>
<p>类似的, 可以通过在描述器中添加值检查, 并且使用mixin类, 联合类型检查:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Positive</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected &gt;= 0&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">PosInteger</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Positive</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">PosFloat</span><span class="p">(</span><span class="n">Float</span><span class="p">,</span> <span class="n">Positive</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>使用新的描述器:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">PosInteger</span><span class="p">(</span><span class="s">&#39;share&#39;</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">PosFloat</span><span class="p">(</span><span class="s">&#39;price&#39;</span><span class="p">)</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__set__</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__set__</span>
<span class="ne">ValueError</span><span class="p">:</span> <span class="n">Expected</span> <span class="o">&gt;=</span> <span class="mi">0</span>
</pre></div>


<h3>理解MRO(方法解析顺序)</h3>
<p>上面使用到了mixin类, 当一个类继承自多个类时, 就有解析顺序的问题, 如上文中的<code>PosInteger</code>类, 其MRO为:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">PosInteger</span><span class="o">.</span><span class="n">__mro__</span>
<span class="p">(</span><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">__main__</span><span class="o">.</span><span class="n">PosInteger</span><span class="s">&#39;&gt;, &lt;class &#39;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Integer</span><span class="s">&#39;&gt;, &lt;class &#39;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Typed</span><span class="s">&#39;&gt;, </span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">__main__</span><span class="o">.</span><span class="n">Positive</span><span class="s">&#39;&gt;, &lt;class &#39;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Descriptor</span><span class="s">&#39;&gt;, &lt;class &#39;</span><span class="nb">object</span><span class="s">&#39;&gt;)</span>
</pre></div>


<p>对于一般的类而言, 方法按照MRO列表的顺序查找, 找到第一个方法之后调用.</p>
<p><code>super()</code>将会返回MRO列表之后的类, 并调用该类的对应方法(注意: 不是父类).</p>
<p>更多关于MRO的内容, 可以参考<a href="https://en.wikipedia.org/wiki/C3_linearization">C3方法</a>的说明.</p>
<h3>添加长度检查</h3>
<p>如果不想让名字长度无限的话, 可以添加一个大小限制的描述器:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Sized</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxlen</span> <span class="o">=</span> <span class="n">maxlen</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxlen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Too big&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SizedString</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">Sized</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>上面使用了一个key-word only的参数技巧, 在*args后面的具名参数, 只能通过键值对的方式传入.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">SizedString</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">PosInteger</span><span class="p">(</span><span class="s">&#39;shares&#39;</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">PosFloat</span><span class="p">(</span><span class="s">&#39;price&#39;</span><span class="p">)</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;ABCDEFGHIJKLMNOPQ&#39;</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__set__</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">8</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__set__</span>
<span class="ne">ValueError</span><span class="p">:</span> <span class="n">Too</span> <span class="n">big</span>
</pre></div>


<h3>添加模式检查</h3>
<p>利用正则表达式, 可以对字符串进行更加深入的模式检查:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>
<span class="k">class</span> <span class="nc">Regex</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid string&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SizedRegexString</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Regex</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>比如限制姓名中只使用大写字母:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">SizedRegexString</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pat</span><span class="o">=</span><span class="s">&#39;[A-Z]+$&#39;</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">PosInteger</span><span class="p">(</span><span class="s">&#39;shares&#39;</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">PosFloat</span><span class="p">(</span><span class="s">&#39;price&#39;</span><span class="p">)</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;WOW!&#39;</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__set__</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">9</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__set__</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">8</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__set__</span>
<span class="ne">ValueError</span><span class="p">:</span> <span class="n">Invalid</span> <span class="n">string</span>
</pre></div>


<p>在这里看到了一件非常神奇的事情, SizedRegexString('name', maxlen=8, pat='[A-Z]+$')可以一次性传入三个参数, 并且这三个参数分别被三个MRO上的类的<code>__init__</code>正确调用, 仅仅是用了key-word only参数的技巧, 每个<code>__init__</code>会取出自己感兴趣的key-word参数, 然后把剩余的参数继续传给下一个<code>__init__</code>, 这就是Python3, 简单直接又如此有效.</p>
<h3>新的元类</h3>
<p>我们做了非常有效的工作, 将各种类型检查通过简单明确描述器来定义, 但是还是有很多重复性代码, 如:</p>
<ol>
<li>_fields看起来非常多余, 因为里面的内容都会在接下来进行定义;</li>
<li>描述器中的name参数也是多余的, 因为我们一直使用属性名称作为name参数;</li>
</ol>
<p>这一切, 都可以通过重写之前的元类可以完成:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="k">class</span> <span class="nc">StructMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NoDupOrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">clsdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Descriptor</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">clsdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">clsobj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">clsdict</span><span class="p">))</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">make_signature</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">clsobj</span><span class="p">,</span> <span class="s">&#39;__signature__&#39;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clsobj</span>
</pre></div>


<p>然后从基本的<code>Descriptor</code>中把<code>__init__</code>函数删除(这个工作在上述代码的<code>__new__</code>中完成了).</p>
<p>现在我们可以<em>干净</em>地使用描述器了:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">SizedRegexString</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pat</span><span class="o">=</span><span class="s">&#39;[A-Z]+$&#39;</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">PosInteger</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">PosFloat</span><span class="p">()</span>
</pre></div>


<p>可以看到, 我们在<code>__prepare__</code>中使用了<code>collections.OrderedDict</code>替代一般的<code>dict</code>来保持属性定义的顺序(这样可以保证在实例化的时候传入正确的位置参数). 更加深入地, 我们可以使用一个不允许重复内容的字典, 来防止属性的重复定义.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">NoDupOrderedDict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;{} already defined&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">StructMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NoDupOrderedDict</span><span class="p">()</span>

    <span class="o">//</span> <span class="o">...</span>
</pre></div>


<p>现在如果重复定义属性, 则会提示错误:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
        <span class="n">price</span> <span class="o">=</span> <span class="n">PosFloat</span><span class="p">()</span>
        <span class="n">price</span> <span class="o">=</span> <span class="n">PosFloat</span><span class="p">()</span>

<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">Stock</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__setitem__</span>
<span class="ne">NameError</span><span class="p">:</span> <span class="n">price</span> <span class="n">already</span> <span class="n">defined</span>
</pre></div>


<p>代码清单: <a href="https://gist.github.com/lozybean/431a8829e09bf5050c02a436360e6567#file-typely-py">typely.py</a></p>
<h2>代码生成</h2>
<h3>性能瓶颈</h3>
<p>性能就像是程序时间的货币, 用这些货币可以购买许多令人兴奋的东西, 如: 开发效率, 可维护性, 甚至仅仅是美观. </p>
<p>我们买到了什么: </p>
<ol>
<li>我们不需要再频繁在<code>__init__</code>中逐一传入参数了;</li>
<li>同时我们还保留了参数签名, 可以正常使用两类参数(附带消耗);</li>
<li>优雅地添加了各种参数的各种检查;</li>
<li>消除了所有的重复代码, 现在使用起来令人愉悦;</li>
</ol>
<p>看看我们的改变:</p>
<div class="highlight"><pre><span class="o">//</span> <span class="n">Simple</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>

<span class="o">//</span> <span class="n">Meta</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">SizedRegexString</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pat</span><span class="o">=</span><span class="s">&#39;[A-Z]+$&#39;</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">PosInteger</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">PosFloat</span><span class="p">()</span>
</pre></div>


<p>在我Python 3.5.0的环境下, 使用line_profiler进行性能检查, 得到结果如下:</p>
<p>Simple:</p>
<div class="highlight"><pre>Wrote profile results to simple.py.lprof
Timer unit: 1e-06 s

Total time: 1.8e-05 s
File: simple.py
Function: test at line 10

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    10                                           @profile
    11                                           def test():
    12         1           12     12.0     66.7      s = Stock(&#39;ACME&#39;, 50, 91.1)
    13         1            3      3.0     16.7      s.price
    14         1            2      2.0     11.1      s.price = 10.0
    15         1            1      1.0      5.6      s.name = &#39;ACME&#39;
</pre></div>


<p>Meta:</p>
<div class="highlight"><pre>Wrote profile results to typely.py.lprof
Timer unit: 1e-06 s

Total time: 0.000238 s
File: typely.py
Function: test at line 117

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   117                                           @profile
   118                                           def test():
   119         1          200    200.0     84.0      s = Stock(&#39;ACME&#39;, 50, 91.1)
   120         1            3      3.0      1.3      s.price
   121         1           13     13.0      5.5      s.price = 10.0
   122         1           22     22.0      9.2      s.name = &#39;ACME&#39;
</pre></div>


<p>性能看来消耗地有点多, 实例化耗时将近17倍(如果是python3.3的话, 这个效率还要低, 大概耗时400个单位, 是python3.5的两倍), 属性设置也在6-22倍(取决于验证的复杂性). 而至于s.price消耗时间相同这个"bright spot"也只是因为我们的描述器中没有对<code>__get__</code>进行重写.</p>
<p>除了类型检查等功能性增加所消耗的性能有价值之外, 附带的消耗成为了性能的瓶颈:</p>
<ol>
<li>使用了签名;</li>
<li>描述器中复杂的继承关系;</li>
</ol>
<h3>代码生成器</h3>
<p>为了避免以上的瓶颈, 我们首先要做一些看起来不怎么好的动作:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_make_init</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s">&#39;def __init__(self, {}):</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fields</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">&#39;    self.{name} = {name}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">code</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">code</span> <span class="o">=</span> <span class="n">_make_init</span><span class="p">([</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;shares&#39;</span><span class="p">,</span> <span class="s">&#39;price&#39;</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
</pre></div>


<p>我们使用一个函数来生成代码字符串, 然后只要在元类中执行这段代码, 就可以避免签名的问题:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">StructMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NoDupOrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">clsdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Descriptor</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">clsdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">exec</span><span class="p">(</span><span class="n">_make_init</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="nb">globals</span><span class="p">(),</span> <span class="n">clsdict</span><span class="p">)</span>
        <span class="n">clsobj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">clsdict</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">clsobj</span>
</pre></div>


<p>使用新的方式的性能结果:</p>
<div class="highlight"><pre>Wrote profile results to execly_init.py.lprof
Timer unit: 1e-06 s

Total time: 0.000108 s
File: execly_init.py
Function: test at line 117

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   117                                           @profile
   118                                           def test():
   119         1           72     72.0     66.7      s = Stock(&#39;ACME&#39;, 50, 91.1)
   120         1            3      3.0      2.8      s.price
   121         1           13     13.0     12.0      s.price = 10.0
   122         1           20     20.0     18.5      s.name = &#39;ACME&#39;
</pre></div>


<p>可以看到, 实例化效率是之前的将近3倍. 虽然这个做法似乎不怎么漂亮, 但是带来的性能提升是实实在在的, 通过代码生成器直接形成逻辑, 避免了使用签名带来的性能瓶颈.</p>
<h3>进一步改良</h3>
<p>既然如此, 能否用代码生成器来解决描述器的继承关系带来的性能瓶颈呢? 到目前为止, 描述器的<code>__set__</code>方法都先有一段检查代码, 然后都使用<code>super()</code>来调用MRO列表中的下一个类的<code>__set__</code>方法.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Descriptor</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">Typed</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ty</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Expected {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ty</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Positive</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected &gt;= 0&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>


<p>首先实现<code>__set__</code>方法中的实现代码:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Descriptor</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set_code</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s">&#39;instance.__dict__[self.name] = value&#39;</span>
        <span class="p">]</span>

<span class="k">class</span> <span class="nc">Typed</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set_code</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s">&#39;print(&quot;this is Typed.__set__&quot;)&#39;</span><span class="p">,</span>
            <span class="s">&#39;if not isinstance(value, self.ty):&#39;</span><span class="p">,</span>
            <span class="s">&#39;    raise TypeError(&quot;Expected {}&quot;.format(self.ty))&#39;</span><span class="p">,</span>
        <span class="p">]</span>

<span class="k">class</span> <span class="nc">Positive</span><span class="p">(</span><span class="n">Descriptor</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set_code</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[</span>
        <span class="s">&#39;print(&quot;this is Positive.__set__&quot;)&#39;</span><span class="p">,</span>
        <span class="s">&#39;if value &lt; 0:&#39;</span><span class="p">,</span>
        <span class="s">&#39;    raise ValueError(&quot;Expected &gt;= 0&quot;)&#39;</span><span class="p">,</span>
        <span class="p">]</span>
</pre></div>


<p>所有的描述器都通过上述示例来修改后, 我们就可以利用MRO来生成最终<code>__set__</code>方法:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_make_setter</span><span class="p">(</span><span class="n">dcls</span><span class="p">):</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s">&#39;def __set__(self, instance, value):</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dcls</span><span class="o">.</span><span class="n">__mro__</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;set_code&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">set_code</span><span class="p">():</span>
                <span class="n">code</span> <span class="o">+=</span> <span class="s">&#39;    &#39;</span> <span class="o">+</span> <span class="n">line</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">return</span> <span class="n">code</span>
</pre></div>


<p>遍历一个类的MRO, 然后其中类的<code>__set__</code>方法拼接起来, 作为最终的<code>__set__</code>方法, 我们最后要做的就只是把这个过程加入到元类中:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">DescriptorMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;__set__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clsdict</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">_make_setter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">exec</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="n">clsdict</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;__set__&#39;</span><span class="p">,</span>
                    <span class="n">clsdict</span><span class="p">[</span><span class="s">&#39;__set__&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Define set_code()&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Descriptor</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">DescriptorMeta</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>


<p>该元类中首先按照之前的逻辑生成最终<code>__set__</code>方法代码, 然后使用<code>exec</code>执行, 并且将执行后的结果设置为<code>self.__set__</code>方法.</p>
<p>看起来和python干的工作是一样的, 再使用line_profiler进行性能检查:</p>
<div class="highlight"><pre>Wrote profile results to execly.py.lprof
Timer unit: 1e-06 s

Total time: 7.3e-05 s
File: execly.py
Function: test at line 154

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   154                                           @profile
   155                                           def test():
   156         1           49     49.0     67.1      s = Stock(&#39;ACME&#39;, 50, 91.1)
   157         1            3      3.0      4.1      s.price
   158         1            8      8.0     11.0      s.price = 10.0
   159         1           13     13.0     17.8      s.name = &#39;ACME&#39;
</pre></div>


<p>属性设置的效率是之前的2倍, 实例化也更快了(提升30%左右), 代码生成器确实对效率有很大改善.</p>
<p>代码清单: <a href="https://gist.github.com/lozybean/431a8829e09bf5050c02a436360e6567#file-execly-py">execly.py</a></p>
<h2>接下来的问题</h2>
<h3>使用XML管理代码</h3>
<p>目前定义类的代码为:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">SizedRegexString</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pat</span><span class="o">=</span><span class="s">&#39;[A-Z]+$&#39;</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">PosInteger</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">PosFloat</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">hostname</span> <span class="o">=</span> <span class="n">String</span><span class="p">()</span>
    <span class="n">port</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>
</pre></div>


<p>干得漂亮, 看上去很干净. 但是如果想隐藏代码细节, 就可以使用XML来管理这些代码:</p>
<div class="highlight"><pre><span class="nt">&lt;structures&gt;</span>
  <span class="nt">&lt;structure</span> <span class="na">name=</span><span class="s">&quot;Stock&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;field</span> <span class="na">type=</span><span class="s">&quot;SizedRegexString&quot;</span> <span class="na">maxlen=</span><span class="s">&quot;8&quot;</span> <span class="na">pat=</span><span class="s">&quot;&#39;[A-Z]+$&#39;&quot;</span><span class="nt">&gt;</span>name<span class="nt">&lt;/field&gt;</span>
    <span class="nt">&lt;field</span> <span class="na">type=</span><span class="s">&quot;PosInteger&quot;</span><span class="nt">&gt;</span>shares<span class="nt">&lt;/field&gt;</span>
    <span class="nt">&lt;field</span> <span class="na">type=</span><span class="s">&quot;PosFloat&quot;</span><span class="nt">&gt;</span>price<span class="nt">&lt;/field&gt;</span>
  <span class="nt">&lt;/structure&gt;</span>

  <span class="nt">&lt;structure</span> <span class="na">name=</span><span class="s">&quot;Point&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;field</span> <span class="na">type=</span><span class="s">&quot;Integer&quot;</span><span class="nt">&gt;</span>x<span class="nt">&lt;/field&gt;</span>
    <span class="nt">&lt;field</span> <span class="na">type=</span><span class="s">&quot;Integer&quot;</span><span class="nt">&gt;</span>y<span class="nt">&lt;/field&gt;</span>
  <span class="nt">&lt;/structure&gt;</span>

 <span class="nt">&lt;structure</span> <span class="na">name=</span><span class="s">&quot;Address&quot;</span><span class="nt">&gt;</span>
   <span class="nt">&lt;field</span> <span class="na">type=</span><span class="s">&quot;String&quot;</span><span class="nt">&gt;</span>hostname<span class="nt">&lt;/field&gt;</span>
   <span class="nt">&lt;field</span> <span class="na">type=</span><span class="s">&quot;Integer&quot;</span><span class="nt">&gt;</span>port<span class="nt">&lt;/field&gt;</span>
 <span class="nt">&lt;/structure&gt;</span>
<span class="nt">&lt;/structures&gt;</span>
</pre></div>


<p>使用下面的方法来解析XML文档, 将之前的元类和描述器保存为typestruct模块, XML文档使用datadefs.xml保存:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">parse</span>

<span class="k">def</span> <span class="nf">_xml_to_code</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s">&#39;import typestruct as _ts</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;structure&#39;</span><span class="p">):</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="n">_xml_struct_code</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">code</span>

<span class="k">def</span> <span class="nf">_xml_struct_code</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
    <span class="n">stname</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s">&#39;class </span><span class="si">%s</span><span class="s">(_ts.Structure):</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">stname</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;field&#39;</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="s">&#39;_ts.&#39;</span> <span class="o">+</span> <span class="n">field</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;type&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                           <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s">&#39;type&#39;</span><span class="p">)</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">&#39;    </span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">(</span><span class="si">%s</span><span class="s">)</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">code</span>
</pre></div>


<p>使用以上解析代码, 可以对XML文档正确解析:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">code</span> <span class="o">=</span> <span class="n">_xml_to_code</span><span class="p">(</span><span class="s">&#39;datadefs.xml&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">typestruct</span> <span class="kn">as</span> <span class="nn">_ts</span>
<span class="k">class</span> <span class="nc">Stock</span><span class="p">(</span><span class="n">_ts</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">_ts</span><span class="o">.</span><span class="n">SizedRegexString</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pat</span><span class="o">=</span><span class="s">&#39;[A-Z]+$&#39;</span><span class="p">)</span>
    <span class="n">shares</span> <span class="o">=</span> <span class="n">_ts</span><span class="o">.</span><span class="n">PosInteger</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">_ts</span><span class="o">.</span><span class="n">PosFloat</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">_ts</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_ts</span><span class="o">.</span><span class="n">Integer</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_ts</span><span class="o">.</span><span class="n">Integer</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">_ts</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">hostname</span> <span class="o">=</span> <span class="n">_ts</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>
    <span class="n">port</span> <span class="o">=</span> <span class="n">_ts</span><span class="o">.</span><span class="n">Integer</span><span class="p">()</span>
</pre></div>


<h3>导入器</h3>
<p>python在带入模块的时候, 其实是在<code>sys.meta_path</code>这个导入器列表中, 使用其中的导入器来导入模块:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span>
<span class="p">[</span><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">_frozen_importlib</span><span class="o">.</span><span class="n">BuiltinImporter</span><span class="s">&#39;&gt;, &lt;class &#39;</span><span class="n">_frozen_importlib</span><span class="o">.</span><span class="n">FrozenImporter</span><span class="s">&#39;&gt;, &lt;class &#39;</span><span class="n">_frozen_importlib_external</span><span class="o">.</span><span class="n">PathFinder</span><span class="s">&#39;&gt;]</span>
</pre></div>


<p>其中的导入器主要实现了<code>find_module</code>方法, 通过实现该方法可以自定义导入器:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>

<span class="k">class</span> <span class="nc">StructImporter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">fullname</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span>
        <span class="k">for</span> <span class="n">dn</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">name</span><span class="o">+</span><span class="s">&#39;.xml&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">StructXMLLoader</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>导入器中会遍历path, 直到找到以<code>.xml</code>结尾的文件, 并返回该文件的模块载入器, 模块载入器是一个实现了<code>load_module</code>方法的类:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">imp</span>
<span class="k">class</span> <span class="nc">StructXMLLoader</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">filename</span>

    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span>
                                     <span class="n">imp</span><span class="o">.</span><span class="n">new_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">__file__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">_xml_to_code</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="n">__dict__</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mod</span>
</pre></div>


<p>在载入器中, 使用了前文的解析方法, 将XML文档解析为python代码, 并且在创建的mod对象环境中执行该代码.</p>
<p>安装导入器的方法是在<code>sys.meta_path</code>中添加该导入器:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">install_importer</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">StructImporter</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

<span class="n">install_importer</span><span class="p">()</span>
</pre></div>


<p>至此, 模块就可以被正常使用了:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">datadefs</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">datadefs</span>
<span class="o">&lt;</span><span class="n">module</span> <span class="s">&#39;datadefs&#39;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">StructXMLLoader</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f84e763e390</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">datadefs</span><span class="o">.</span><span class="n">Stock</span><span class="p">(</span><span class="s">&#39;ACME&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">91.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">price</span>
<span class="mf">91.1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">inspect</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">datadefs</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">structures</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">structure</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Stock&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">field</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;SizedRegexString&quot;</span> <span class="n">maxlen</span><span class="o">=</span><span class="s">&quot;8&quot;</span> <span class="n">pat</span><span class="o">=</span><span class="s">&quot;&#39;[A-Z]+$&#39;&quot;</span><span class="o">&gt;</span><span class="n">name</span><span class="o">&lt;/</span><span class="n">field</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">field</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;PosInteger&quot;</span><span class="o">&gt;</span><span class="n">shares</span><span class="o">&lt;/</span><span class="n">field</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">field</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;PosFloat&quot;</span><span class="o">&gt;</span><span class="n">price</span><span class="o">&lt;/</span><span class="n">field</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">structure</span><span class="o">&gt;</span>

  <span class="o">&lt;</span><span class="n">structure</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Point&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">field</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;Integer&quot;</span><span class="o">&gt;</span><span class="n">x</span><span class="o">&lt;/</span><span class="n">field</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">field</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;Integer&quot;</span><span class="o">&gt;</span><span class="n">y</span><span class="o">&lt;/</span><span class="n">field</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">structure</span><span class="o">&gt;</span>

 <span class="o">&lt;</span><span class="n">structure</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Address&quot;</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">field</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;String&quot;</span><span class="o">&gt;</span><span class="n">hostname</span><span class="o">&lt;/</span><span class="n">field</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">field</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;Integer&quot;</span><span class="o">&gt;</span><span class="n">port</span><span class="o">&lt;/</span><span class="n">field</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="n">structure</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">structures</span><span class="o">&gt;</span>
</pre></div>


<p>代码清单: <a href="https://gist.github.com/lozybean/431a8829e09bf5050c02a436360e6567#file-importly-py">importly.py</a></p>
<h2>总结</h2>
<h3>我们做了什么</h3>
<ol>
<li>像建筑积木一样使用描述器;</li>
<li>隐藏讨厌的细节(签名等);</li>
<li>动态代码生成;</li>
<li>自定义导入;</li>
</ol>
<p>而这些工作都没有做任何的'hack', 所有的一切都在python3的设计之中, 使用python3可以更加优雅地实现很多事情.</p>
<h3>这只是开始</h3>
<p>python3还有很多好用的特性:</p>
<ul>
<li>函数注释:</li>
</ul>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>


<ul>
<li>非本地变量:</li>
</ul>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="n">nonlocal</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">newvalue</span>
    <span class="o">...</span>
</pre></div>


<ul>
<li>上下文管理器:</li>
</ul>
<div class="highlight"><pre><span class="k">with</span> <span class="n">m</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>


<ul>
<li>Frame-hacks</li>
</ul>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getfrmae</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>


<ul>
<li>代码修改器:</li>
</ul>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">ast</span>
</pre></div>


<h3>什么时候使用元编程</h3>
<p>元编程并不是正常的编程, 他常常在框架或者库中使用, 在日常编程工作中, 保持简单并不是一个不好的方案.</p>
<h2>引用</h2>
<p>本文根据<a href="https://www.youtube.com/watch?time_continue=1&amp;v=sPiWg5jSoZI">David Beazley 13年pycon的演讲</a>以及<a href="http://www.dabeaz.com/py3meta/Py3Meta.pdf">对应的ppt</a>整理.</p>
            </div>
            <!-- /.entry-content -->

    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>
<!--         <div class="ds-thread" data-thread-key="python3yuan-bian-cheng-ji-qiao" data-title="Python3元编程技巧" data-url="http://www.lyon0804.com/python3yuan-bian-cheng-ji-qiao.html"></div> -->
		<script type="text/javascript">
     		var duoshuoQuery = {short_name:"lyon0804"};
    		(function() {
    			var ds = document.createElement('script');
    			ds.type = 'text/javascript';ds.async = true;
    			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    			ds.charset = 'UTF-8';
    			(document.getElementsByTagName('head')[0]
    			 || document.getElementsByTagName('body')[0]).appendChild(ds);
    		})();
    	</script>
        <script type="text/javascript">
            function toggleDuoshuoComments(container, id, title, url){
                if(jQuery(container).has("div").length>0){
                    jQuery(container).empty();
                    return;
                }
                var el = document.createElement('div');
                el.setAttribute('class','ds-thread');
                el.setAttribute('data-thread-key', id);
                el.setAttribute('data-title',title);
                el.setAttribute('data-url', url);
                DUOSHUO.EmbedThread(el);
                jQuery(container).append(el);
            }
        </script>
        <a href="javascript:void(0);" onclick="toggleDuoshuoComments('#comment-box', 'python3yuan-bian-cheng-ji-qiao', 'Python3元编程技巧' , 'http://www.lyon0804.com/python3yuan-bian-cheng-ji-qiao.html');">
        查看评论</a>
        <div id="comment-box" ></div>
        <hr/>
    	<noscript>Please enable JavaScript to view the <a href="http://duoshuo.com/">comments powered by
        Duoshuo.</a></noscript>
    	<a href="http://duoshuo.com" class="dsq-brlink">comments powered by <span>Duoshuo</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
            <!-- <div class="list-group-item"> -->
            <!-- <h4> -->
            <!-- <i class="fa fa-home fa-lg"></i> -->
            <!-- <span class="icon-label">Social</span></h4> -->
              <ul class="list-group" id="social">
                   <!-- <li class="list-group-item"> -->
                   <div class="social-item">
                   <a href="http://github.com/lozybean">
                     <i class="fa fa-github-square fa-lg"></i><!--  github -->
                   </a>
                   </div>
                   <!-- </li> -->
                   <!-- <li class="list-group-item"> -->
                   <div class="social-item">
                   <a href="http://weibo.com/lyon0804">
                     <i class="fa fa-weibo fa-lg"></i><!--  weibo -->
                   </a>
                   </div>
                   <!-- </li> -->
              </ul>
            <!-- </div> -->
         <div class="col-xs-10">&copy; 2016 lyon
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3(modified by lyon)</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2" id="back-top">
            <!-- <p class="pull-right"><i class="fa fa-arrow-up"></i>  -->
            <a href="#top" title="回到顶部"></a>
            </p>
         </div>
      </div>
   </div>
</footer>
<script src="http://www.lyon0804.com/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://www.lyon0804.com/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://www.lyon0804.com/theme/js/respond.min.js"></script>


</body>
</html>